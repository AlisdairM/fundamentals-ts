<cxx-clause id="container">
  <h1>Containers</h1>

  <cxx-section id="container.erasure">
    <h1>Uniform container erasure</h1>

    <cxx-section id="container.erasure.syn">
      <h1>Header synopsis</h1>

      <p>
        For brevity, this section specifies the contents of 9 headers,
        each of which behaves as described by <cxx-ref to="general.namespaces"></cxx-ref>.
      </p>

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.erasure.erase_if"></cxx-ref>
  <cxx-ref insynopsis="" to="container.erasure.erase"></cxx-ref>

  // &lt;experimental/string>
  template &lt;class charT, class traits, class A, class Predicate>
    void erase_if(basic_string&lt;charT, traits, A>&amp; c, Predicate pred);
  template &lt;class charT, class traits, class A, class U>
    void erase(basic_string&lt;charT, traits, A>&amp; c, const U&amp; value);

  // &lt;experimental/deque>
  template &lt;class T, class A, class Predicate>
    void erase_if(deque&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(deque&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/vector>
  template &lt;class T, class A, class Predicate>
    void erase_if(vector&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(vector&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/forward_list>
  template &lt;class T, class A, class Predicate>
    void erase_if(forward_list&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(forward_list&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/list>
  template &lt;class T, class A, class Predicate>
    void erase_if(list&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(list&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/map>
  template &lt;class K, class T, class C, class A, class Predicate>
    void erase_if(map&lt;K, T, C, A>&amp; c, Predicate pred);
  template &lt;class K, class T, class C, class A, class Predicate>
    void erase_if(multimap&lt;K, T, C, A>&amp; c, Predicate pred);

  // &lt;experimental/set>
  template &lt;class K, class C, class A, class Predicate>
    void erase_if(set&lt;K, C, A>&amp; c, Predicate pred);
  template &lt;class K, class C, class A, class Predicate>
    void erase_if(multiset&lt;K, C, A>&amp; c, Predicate pred);

  // &lt;experimental/unordered_map>
  template &lt;class K, class T, class H, class P, class A, class Predicate>
    void erase_if(unordered_map&lt;K, T, H, P, A>&amp; c, Predicate pred);
  template &lt;class K, class T, class H, class P, class A, class Predicate>
    void erase_if(unordered_multimap&lt;K, T, H, P, A>&amp; c, Predicate pred);

  // &lt;experimental/unordered_set>
  template &lt;class K, class H, class P, class A, class Predicate>
    void erase_if(unordered_set&lt;K, H, P, A>&amp; c, Predicate pred);
  template &lt;class K, class H, class P, class A, class Predicate>
    void erase_if(unordered_multiset&lt;K, H, P, A>&amp; c, Predicate pred);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="container.erasure.erase_if">
      <h1>Function template <code>erase_if</code></h1>

      <cxx-function>
        <cxx-signature>template &lt;class charT, class traits, class A, class Predicate>
void erase_if(basic_string&lt;charT, traits, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(deque&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(vector&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.erase(remove_if(c.begin(), c.end(), pred), c.end());</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(forward_list&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(list&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.remove_if(pred);</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class K, class T, class C, class A, class Predicate>
void erase_if(map&lt;K, T, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class C, class A, class Predicate>
void erase_if(multimap&lt;K, T, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class C, class A, class Predicate>
void erase_if(set&lt;K, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class C, class A, class Predicate>
void erase_if(multiset&lt;K, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate>
void erase_if(unordered_map&lt;K, T, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate>
void erase_if(unordered_multimap&lt;K, T, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class H, class P, class A, class Predicate>
void erase_if(unordered_set&lt;K, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class H, class P, class A, class Predicate>
void erase_if(unordered_multiset&lt;K, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to:
<pre><code>for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}</code></pre></cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="container.erasure.erase">
      <h1>Function template erase</h1>

      <cxx-function>
        <cxx-signature>template &lt;class charT, class traits, class A, class U>
void erase(basic_string&lt;charT, traits, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(deque&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(vector&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.erase(remove(c.begin(), c.end(), value), c.end());</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(forward_list&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(list&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-effects>Equivalent to: <code>erase_if(c, [&amp;](auto&amp; elem) { return elem == value; });</code></cxx-effects>
      </cxx-function>

      <cxx-note>
        Overloads of <code>erase()</code> for associative containers and unordered associative containers are intentionally not provided.
      </cxx-note>
    </cxx-section>
  </cxx-section>

  <cxx-section id="container.array">
    <h1>Class template <code>array</code></h1>

    <cxx-section id="header.array.synop">
      <h1>Header &lt;experimental/array> synopsis</h1>

      <pre><code>#include &lt;array>

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis to="container.array.creation"></cxx-ref>
  template &lt;class D = void, class... Types&gt;
    constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);
  template &lt;class T, size_t N&gt;
    constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="container.array.creation">
      <h1>Array creation functions</h1>

      <cxx-function>
        <cxx-signature>template &lt;class D = void, class... Types&gt;
&nbsp;&nbsp;constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);</cxx-signature>

        <p>
          Let <em>Ui</em> be <code>decay_t&lt;</code><em>Ti</em><code>&gt;</code> for each <em>Ti</em> in <code>Types</code>.
        </p>
        <cxx-remarks>
          The program is ill-formed if <code>D</code> is <code>void</code> and at least one <em>Ui</em> is a specialization of <code>reference_wrapper</code>.
        </cxx-remarks>
        <cxx-returns>
          <code>array&lt;<var>VT</var>, sizeof...(Types)&gt;{ std::forward&lt;Types&gt;(t)... }</code>, where <code><var>VT</var></code> is <code>common_type_t&lt;Types...&gt;</code> if <code>D</code> is <code>void</code>, otherwise <code><var>VT</var></code> is <code>D</code>.
        </cxx-returns>

        <cxx-example>
<pre><code>int i = 1; int&amp; ri = i;
auto a1 = make_array(i, ri);         // a1<i> is of type </i>array&lt;int, 2&gt;
auto a2 = make_array(i, ri, 42L);    // a2<i> is of type </i>array&lt;long, 3&gt;
auto a3 = make_array&lt;long&gt;(i, ri);   // a3<i> is of type </i>array&lt;long, 2&gt;
auto a4 = make_array&lt;long&gt;();        // a4<i> is of type </i>array&lt;long, 0&gt;
auto a5 = make_array();              // <i>ill-formed</i></code></pre>
        </cxx-example>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, size_t N&gt;
constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);</cxx-signature>

        <cxx-returns>
          An <code>array&lt;remove_cv_t&lt;T&gt;, N&gt;</code> such that each element is copy-initialized with the corresponding element of <code>a</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>
  </cxx-section>
</cxx-clause>
