<cxx-clause id="container">
  <h1>Containers</h1>

  <cxx-section id="container.erasure">
    <h1>Uniform container erasure</h1>

    <cxx-section id="container.erasure.syn">
      <h1>Header synopsis</h1>

      <p>
        For brevity, this section specifies the contents of 9 headers,
        each of which behaves as described by <cxx-ref to="general.namespaces"></cxx-ref>.
      </p>

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.erasure.erase_if"></cxx-ref>
  <cxx-ref insynopsis="" to="container.erasure.erase"></cxx-ref>

  // &lt;experimental/string>
  template &lt;class charT, class traits, class A, class Predicate>
    void erase_if(basic_string&lt;charT, traits, A>&amp; c, Predicate pred);
  template &lt;class charT, class traits, class A, class U>
    void erase(basic_string&lt;charT, traits, A>&amp; c, const U&amp; value);

  // &lt;experimental/deque>
  template &lt;class T, class A, class Predicate>
    void erase_if(deque&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(deque&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/vector>
  template &lt;class T, class A, class Predicate>
    void erase_if(vector&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(vector&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/forward_list>
  template &lt;class T, class A, class Predicate>
    void erase_if(forward_list&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(forward_list&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/list>
  template &lt;class T, class A, class Predicate>
    void erase_if(list&lt;T, A>&amp; c, Predicate pred);
  template &lt;class T, class A, class U>
    void erase(list&lt;T, A>&amp; c, const U&amp; value);

  // &lt;experimental/map>
  template &lt;class K, class T, class C, class A, class Predicate>
    void erase_if(map&lt;K, T, C, A>&amp; c, Predicate pred);
  template &lt;class K, class T, class C, class A, class Predicate>
    void erase_if(multimap&lt;K, T, C, A>&amp; c, Predicate pred);

  // &lt;experimental/set>
  template &lt;class K, class C, class A, class Predicate>
    void erase_if(set&lt;K, C, A>&amp; c, Predicate pred);
  template &lt;class K, class C, class A, class Predicate>
    void erase_if(multiset&lt;K, C, A>&amp; c, Predicate pred);

  // &lt;experimental/unordered_map>
  template &lt;class K, class T, class H, class P, class A, class Predicate>
    void erase_if(unordered_map&lt;K, T, H, P, A>&amp; c, Predicate pred);
  template &lt;class K, class T, class H, class P, class A, class Predicate>
    void erase_if(unordered_multimap&lt;K, T, H, P, A>&amp; c, Predicate pred);

  // &lt;experimental/unordered_set>
  template &lt;class K, class H, class P, class A, class Predicate>
    void erase_if(unordered_set&lt;K, H, P, A>&amp; c, Predicate pred);
  template &lt;class K, class H, class P, class A, class Predicate>
    void erase_if(unordered_multiset&lt;K, H, P, A>&amp; c, Predicate pred);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="container.erasure.erase_if">
      <h1>Function template <code>erase_if</code></h1>

      <cxx-function>
        <cxx-signature>template &lt;class charT, class traits, class A, class Predicate>
void erase_if(basic_string&lt;charT, traits, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(deque&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(vector&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.erase(remove_if(c.begin(), c.end(), pred), c.end());</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(forward_list&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class Predicate>
void erase_if(list&lt;T, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.remove_if(pred);</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class K, class T, class C, class A, class Predicate>
void erase_if(map&lt;K, T, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class C, class A, class Predicate>
void erase_if(multimap&lt;K, T, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class C, class A, class Predicate>
void erase_if(set&lt;K, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class C, class A, class Predicate>
void erase_if(multiset&lt;K, C, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate>
void erase_if(unordered_map&lt;K, T, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate>
void erase_if(unordered_multimap&lt;K, T, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class H, class P, class A, class Predicate>
void erase_if(unordered_set&lt;K, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-signature>template &lt;class K, class H, class P, class A, class Predicate>
void erase_if(unordered_multiset&lt;K, H, P, A>&amp; c, Predicate pred);</cxx-signature>
        <cxx-effects>Equivalent to:
<pre><code>for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}</code></pre></cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="container.erasure.erase">
      <h1>Function template erase</h1>

      <cxx-function>
        <cxx-signature>template &lt;class charT, class traits, class A, class U>
void erase(basic_string&lt;charT, traits, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(deque&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(vector&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-effects>Equivalent to: <code>c.erase(remove(c.begin(), c.end(), value), c.end());</code></cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(forward_list&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class T, class A, class U>
void erase(list&lt;T, A>&amp; c, const U&amp; value);</cxx-signature>
        <cxx-effects>Equivalent to: <code>erase_if(c, [&amp;](auto&amp; elem) { return elem == value; });</code></cxx-effects>
      </cxx-function>

      <cxx-note>
        Overloads of <code>erase()</code> for associative containers and unordered associative containers are intentionally not provided.
      </cxx-note>
    </cxx-section>
  </cxx-section>
</cxx-clause>
