<cxx-clause id="utilities">
  <h1>General utilities library</h1>

  <cxx-section id="propagate_const">
    <h1>Class template <code>propagate_const</code></h1>

    <cxx-section id="propagate_const.general">
      <h1>Class template <code>propagate_const</TT> general</code></h1>

      <p>
        <code>propagate_const</code> is a wrapper around a pointer-like object type <code>T</code>
        which treats the wrapped pointer as a pointer to <code>const</code> when
        the wrapper is accessed through a <code>const</code> access path.
      </p>
    </cxx-section>

    <cxx-section id="propagate_const.synopsis">
      <h1>Header <code>&lt;experimental/propagate_const&gt;</code> synopsis</h1>

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {
    template &lt;class T&gt; class propagate_const {
    public:
      typedef remove_reference_t&lt;decltype(*declval&lt;T&amp;&gt;())&gt; element_type;

      <cxx-ref insynopsis to="propagate_const.ctor"></cxx-ref>
      constexpr propagate_const() = default;
      propagate_const(const propagate_const&amp; p) = delete;
      constexpr propagate_const(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(U&amp;&amp; u);

      <cxx-ref insynopsis to="propagate_const.assignment"></cxx-ref>
      propagate_const&amp; operator=(const propagate_const&amp; p) = delete;
      constexpr propagate_const&amp; operator=(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(U&amp;&amp; u);

      <cxx-ref insynopsis to="propagate_const.const_observers"></cxx-ref>
      explicit constexpr operator bool() const;
      constexpr const element_type* operator-&gt;() const;
      constexpr operator const element_type*() const; // <i>Not always defined</i>
      constexpr const element_type&amp; operator*() const;
      constexpr const element_type* get() const;

      <cxx-ref insynopsis to="propagate_const.non_const_observers"></cxx-ref>
      constexpr element_type* operator-&gt;();
      constexpr operator element_type*(); // <i>Not always defined</i>
      constexpr element_type&amp; operator*();
      constexpr element_type* get();

      <cxx-ref insynopsis to="propagate_const.modifiers"></cxx-ref>
      constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);

    private:
      T t_; //<i>exposition only</i>
    };

    <cxx-ref insynopsis to="propagate_const.relational"></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);

    <cxx-ref insynopsis to="propagate_const.algorithms"></cxx-ref>
    template &lt;class T&gt;
      constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);

    <cxx-ref insynopsis to="propagate_const.underlying"></cxx-ref>
    template &lt;class T&gt;
      constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;
    template &lt;class T&gt;
      constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;
  } // inline namespace fundamentals_v2
  } // namespace experimental

  <cxx-ref insynopsis to="propagate_const.hash"></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt;
    struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;

  <cxx-ref insynopsis to="propagate_const.comparison_function_objects"></cxx-ref>
  template &lt;class T&gt; struct equal_to;
  template &lt;class T&gt;
    struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct not_equal_to;
  template &lt;class T&gt;
    struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less;
  template &lt;class T&gt;
    struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater;
  template &lt;class T&gt;
    struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less_equal;
  template &lt;class T&gt;
    struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater_equal;
  template &lt;class T&gt;
    struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
} // namespace std</code></pre>
    </cxx-section>

    <cxx-section id="propagate_const.requirements">
      <h1><code>propagate_const</code> requirements on <code>T</code></h1>

      <p>
        <code>T</code> shall be an object pointer type or a class type for which
        <code>decltype(*declval&lt;T&amp;&gt;())</code> is an lvalue reference; otherwise
        the program is ill-formed.
      </p>
      <p>
        If <code>T</code> is an array type, reference type, pointer to function type or
        pointer to (possibly cv-qualified) <code>void</code>, then the program is
        ill-formed.
      </p>
      <p>
        <cxx-note><code>propagate_const&lt;const int*&gt;</code> is well-formed</cxx-note>
      </p>

      <cxx-section id="propagate_const.class_type_requirements">
        <h1><code>propagate_const</code> requirements on class type <code>T</code></h1>

        <p>
          If <code>T</code> is class
          type then it shall satisfy the following requirements. In this sub-clause
          <code>t</code> denotes a non-<code>const</code> lvalue of type <code>T</code>, <code>ct</code>
          is a <code>const T&amp;</code> bound to <code>t</code>,  <code>element_type</code> denotes
          an object type.
        </p>

        <p>
          <code>T</code> and <code>const T</code> shall be contextually convertible to <code>bool</code>.
        </p>
        <p>If <code>T</code> is implicitly convertible to <code>element_type*</code>,
          <code>(element_type*)t == t.get()</code> shall be <code>true</code>.
        </p>
        <p>
          If <code>const T</code> is implicitly convertible to <code>const element_type*</code>,
          <code>(const element_type*)ct == ct.get()</code> shall be <code>true</code>.
        </p>

        <table is="cxx-table">
          <caption>Requirements on class types <code>T</code></caption>
          <tr>
            <th>Expression</th>
            <th>Return type</th>
            <th>Pre-conditions</th>
            <th>Operational semantics</th>
          </tr>
          <tr>
            <td><code>t.get()</code></td>
            <td><code>element_type*</code></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>ct.get()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code></code></td>
            <td><code>t.get() == ct.get()</code>.</td>
          </tr>
          <tr>
            <td><code>*t</code></td>
            <td><code>element_type&amp;</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>*t</code> refers to the same object as <code>*(t.get())</code></td>
          </tr>
          <tr>
            <td><code>*ct</code></td>
            <td><code>const element_type&amp;</code> or <code>element_type&amp;</code>
            </td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>*ct</code> refers to the same object as <code>*(ct.get())</code>
            </td></tr>
          <tr>
            <td><code>t.operator-&gt;()</code></td>
            <td><code>element_type*</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>t.operator-&gt;() == t.get()</code></td></tr>
          <tr>
            <td><code>ct.operator-&gt;()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>ct.operator-&gt;() == ct.get()</code></td></tr>
          <tr>
            <td><code>(bool)t</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)t</code> is equivalent to <code>t.get() != nullptr</code></td>
          </tr>
          <tr>
            <td><code>(bool)ct</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)ct</code> is equivalent to <code>ct.get() != nullptr</code></td>
          </tr>
        </table>
      </cxx-section>
    </cxx-section>

    <cxx-section id="propagate_const.ctor">
      <h1><code>propagate_const</code> constructors</h1>

      <p>
        <cxx-note>The following constructors are conditionally specified as
          <code>explicit</code>.  This is typically implemented by declaring two such
          constructors, of which at most one  participates in overload resolution.</cxx-note>
      </p>
      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu)</cxx-signature>

        <cxx-remarks>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </cxx-remarks>
        <cxx-effects>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with the
          expression <code>std::move(pu.t_)</code>.
        </cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(U&amp;&amp; u)</cxx-signature>

        <cxx-remarks>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>
          and <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </cxx-remarks>
        <cxx-effects>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with
          the expression <code>std::forward&lt;U&gt;(u)</code>.
        </cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.assignment">
      <h1><code>propagate_const</code> assignment</h1>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(propagate_const&lt;U&gt;&amp;&amp; pu)</cxx-signature>

        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code>.
        </cxx-remarks>
        <cxx-effects><code>t_ = std::move(pu.t_)</code>.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(U&amp;&amp; u)</cxx-signature>

        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code> and
          <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
        </cxx-remarks>
        <cxx-effects><code>t_ = std::forward&lt;U&gt;(u)</code>.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.const_observers">
      <h1><code>propagate_const</code> const observers</h1>

      <cxx-function>
        <cxx-signature>explicit constexpr operator bool() const</cxx-signature>

        <cxx-returns><code>(bool)t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type* operator-&gt;() const</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr operator const element_type*() const</cxx-signature>

        <cxx-returns><code>get()</code>.</cxx-returns>
        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>const element_type*</code>.
        </cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type&amp; operator*() const</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>*get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr const element_type* get() const</cxx-signature>

        <cxx-returns>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.non_const_observers">
      <h1><code>propagate_const</code> non-const observers</h1>

      <cxx-function>
        <cxx-signature>constexpr element_type* operator-&gt;()</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr operator element_type*()</cxx-signature>

        <cxx-returns><code>get()</code>.</cxx-returns>
        <cxx-remarks>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>element_type*</code>.
        </cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type&amp; operator*()</cxx-signature>

        <cxx-requires><code>get() != nullptr</code>.</cxx-requires>
        <cxx-returns><code>*get()</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr element_type* get()</cxx-signature>

        <cxx-returns>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.modifiers">
      <h1><code>propagate_const</code> modifiers</h1>

      <cxx-function>
        <cxx-signature>constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>)</cxx-signature>

        <p>
          The constant-expression in the exception-specification is <code>noexcept(swap(t_, pt.t_))</code>.
        </p>

        <cxx-effects><code>swap(t_, pt.t_)</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.relational">
      <h1><code>propagate_const</code> relational operators</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t)</cxx-signature>

        <cxx-returns><code>pt.t_ == nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator==(nullptr_t, const propagate_const&lt;U&gt;&amp; pt)</cxx-signature>

        <cxx-returns><code>nullptr == pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t)</cxx-signature>

        <cxx-returns><code>pt.t_ != nullptr</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pt)</cxx-signature>

        <cxx-returns><code>nullptr != pt.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>

        <cxx-returns><code>pt.t_ == u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>
        <cxx-returns><code>pt.t_ != u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>

        <cxx-returns><code>pt.t_ &lt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>

        <cxx-returns><code>pt.t_ &gt; u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>

        <cxx-returns><code>pt.t_ &lt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature>

        <cxx-returns><code>pt.t_ &gt;= u</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t == pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t != pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t &lt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t &gt; pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t &lt;= pu.t_</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature>

        <cxx-returns><code>t &gt;= pu.t_</code>.</cxx-returns>
      </cxx-function>
    </cxx-section>
    <cxx-section id="propagate_const.algorithms">
      <h1><code>propagate_const</code> specialized algorithms</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>)</cxx-signature>

        <p>
          The constant-expression in the exception-specification is <code>noexcept(swap(pt1.t_, pt2.t_))</code>.
        </p>

        <cxx-effects><code>swap(pt1.t_, pt2.t_)</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.underlying">
      <h1><code>propagate_const</code> underlying pointer access</h1>

      <p>
        Access to the underlying object pointer type is
        through free functions rather than member functions.
        These functions are intended to resemble cast operations to encourage caution when using them.
      </p>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept</cxx-signature>

        <cxx-returns>
          a reference to the underlying object pointer type.
        </cxx-returns>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.hash">
      <h1><code>propagate_const</code> hash support</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For an object <code>p</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p)</code>
          shall evaluate to the same value as <code>hash&lt;T&gt;()(p.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>hash&lt;T&gt;</code> shall be well-formed and well-defined,
          and shall meet the requirements of class template hash.
        </cxx-requires>
      </cxx-function>
    </cxx-section>

    <cxx-section id="propagate_const.comparison_function_objects">
      <h1><code>propagate_const</code> comparison function objects</h1>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>equal_to&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>not_equal_to&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>not_equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>less&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>greater&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less_equal&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>less_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class T&gt;
struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature>

        <p>
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires>
          The specialization <code>greater_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </cxx-requires>
      </cxx-function>
    </cxx-section>
  </cxx-section>
</cxx-clause>
