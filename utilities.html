<cxx-clause id="utilities">
  <h1>General utilities library</h1>

  <cxx-section id="utility">
    <h1>Utility components</h1>

    <cxx-section id="utility.synop">
      <h1>Header <code>&lt;experimental/utility></code> synopsis</h1>

<pre><code>#include &lt;utility>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

 <cxx-ref to="utility.erased.type"></cxx-ref>, erased-type placeholder
 struct erased_type { };

}
}
}</code></pre>

    </cxx-section>

    <cxx-section id="utility.erased.type">
      <h1>Class <code>erased_type</code></h1>

      <cxx-function>
        <cxx-signature>struct erased_type { };</cxx-signature>

        <p>
          The <code>erased_type</code> <code>struct</code> is an empty <code>struct</code> that serves as a placeholder for a type <code>T</code> in situations where the actual type <code>T</code> is determined at runtime.
          For example, the nested type, <code>allocator_type</code>, is an alias for <code>erased_type</code> in classes that use <i>type-erased allocators</i> (see <cxx-ref to="memory.type.erased.allocator"></cxx-ref>).
        </p>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="tuple">
    <h1>Tuples</h1>

    <cxx-section id="header.tuple.synop">
      <h1>Header &lt;experimental/tuple> synopsis</h1>

<pre><code>#include &lt;tuple>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

// See <cxx-ref in="cxx" to="tuple.helper"></cxx-ref>, tuple helper classes
template &lt;class T> constexpr size_t tuple_size_v
  = tuple_size&lt;T>::value;

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="meta">
    <h1>Metaprogramming and type traits</h1>

    <cxx-section id="meta.type.synop">
      <h1>Header &lt;experimental/type_traits> synopsis</h1>

<pre><code>#include &lt;type_traits>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

// See <cxx-ref in="cxx" to="meta.unary.cat"></cxx-ref>, primary type categories
template &lt;class T> constexpr bool is_void_v
  = is_void&lt;T>::value;
template &lt;class T> constexpr bool is_null_pointer_v
  = is_null_pointer&lt;T>::value;
template &lt;class T> constexpr bool is_integral_v
  = is_integral&lt;T>::value;
template &lt;class T> constexpr bool is_floating_point_v
  = is_floating_point&lt;T>::value;
template &lt;class T> constexpr bool is_array_v
  = is_array&lt;T>::value;
template &lt;class T> constexpr bool is_pointer_v
  = is_pointer&lt;T>::value;
template &lt;class T> constexpr bool is_lvalue_reference_v
  = is_lvalue_reference&lt;T>::value;
template &lt;class T> constexpr bool is_rvalue_reference_v
  = is_rvalue_reference&lt;T>::value;
template &lt;class T> constexpr bool is_member_object_pointer_v
  = is_member_object_pointer&lt;T>::value;
template &lt;class T> constexpr bool is_member_function_pointer_v
  = is_member_function_pointer&lt;T>::value;
template &lt;class T> constexpr bool is_enum_v
  = is_enum&lt;T>::value;
template &lt;class T> constexpr bool is_union_v
  = is_union&lt;T>::value;
template &lt;class T> constexpr bool is_class_v
  = is_class&lt;T>::value;
template &lt;class T> constexpr bool is_function_v
  = is_function&lt;T>::value;

// See <cxx-ref in="cxx" to="meta.unary.comp"></cxx-ref>, composite type categories
template &lt;class T> constexpr bool is_reference_v
  = is_reference&lt;T>::value;
template &lt;class T> constexpr bool is_arithmetic_v
  = is_arithmetic&lt;T>::value;
template &lt;class T> constexpr bool is_fundamental_v
  = is_fundamental&lt;T>::value;
template &lt;class T> constexpr bool is_object_v
  = is_object&lt;T>::value;
template &lt;class T> constexpr bool is_scalar_v
  = is_scalar&lt;T>::value;
template &lt;class T> constexpr bool is_compound_v
  = is_compound&lt;T>::value;
template &lt;class T> constexpr bool is_member_pointer_v
  = is_member_pointer&lt;T>::value;

// See <cxx-ref in="cxx" to="meta.unary.prop"></cxx-ref>, type properties
template &lt;class T> constexpr bool is_const_v
  = is_const&lt;T>::value;
template &lt;class T> constexpr bool is_volatile_v
  = is_volatile&lt;T>::value;
template &lt;class T> constexpr bool is_trivial_v
  = is_trivial&lt;T>::value;
template &lt;class T> constexpr bool is_trivially_copyable_v
  = is_trivially_copyable&lt;T>::value;
template &lt;class T> constexpr bool is_standard_layout_v
  = is_standard_layout&lt;T>::value;
template &lt;class T> constexpr bool is_pod_v
  = is_pod&lt;T>::value;
template &lt;class T> constexpr bool is_literal_type_v
  = is_literal_type&lt;T>::value;
template &lt;class T> constexpr bool is_empty_v
  = is_empty&lt;T>::value;
template &lt;class T> constexpr bool is_polymorphic_v
  = is_polymorphic&lt;T>::value;
template &lt;class T> constexpr bool is_abstract_v
  = is_abstract&lt;T>::value;
template &lt;class T> constexpr bool is_final_v
  = is_final&lt;T>::value;
template &lt;class T> constexpr bool is_signed_v
  = is_signed&lt;T>::value;
template &lt;class T> constexpr bool is_unsigned_v
  = is_unsigned&lt;T>::value;
template &lt;class T, class... Args> constexpr bool is_constructible_v
  = is_constructible&lt;T, Args...>::value;
template &lt;class T> constexpr bool is_default_constructible_v
  = is_default_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_copy_constructible_v
  = is_copy_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_move_constructible_v
  = is_move_constructible&lt;T>::value;
template &lt;class T, class U> constexpr bool is_assignable_v
  = is_assignable&lt;T, U>::value;
template &lt;class T> constexpr bool is_copy_assignable_v
  = is_copy_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_move_assignable_v
  = is_move_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_destructible_v
  = is_destructible&lt;T>::value;
template &lt;class T, class... Args> constexpr bool is_trivially_constructible_v
  = is_trivially_constructible&lt;T, Args...>::value;
template &lt;class T> constexpr bool is_trivially_default_constructible_v
  = is_trivially_default_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_trivially_copy_constructible_v
  = is_trivially_copy_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_trivially_move_constructible_v
  = is_trivially_move_constructible&lt;T>::value;
template &lt;class T, class U> constexpr bool is_trivially_assignable_v
  = is_trivially_assignable&lt;T, U>::value;
template &lt;class T> constexpr bool is_trivially_copy_assignable_v
  = is_trivially_copy_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_trivially_move_assignable_v
  = is_trivially_move_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_trivially_destructible_v
  = is_trivially_destructible&lt;T>::value;
template &lt;class T, class... Args> constexpr bool is_nothrow_constructible_v
  = is_nothrow_constructible&lt;T, Args...>::value;
template &lt;class T> constexpr bool is_nothrow_default_constructible_v
  = is_nothrow_default_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_nothrow_copy_constructible_v
  = is_nothrow_copy_constructible&lt;T>::value;
template &lt;class T> constexpr bool is_nothrow_move_constructible_v
  = is_nothrow_move_constructible&lt;T>::value;
template &lt;class T, class U> constexpr bool is_nothrow_assignable_v
  = is_nothrow_assignable&lt;T, U>::value;
template &lt;class T> constexpr bool is_nothrow_copy_assignable_v
  = is_nothrow_copy_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_nothrow_move_assignable_v
  = is_nothrow_move_assignable&lt;T>::value;
template &lt;class T> constexpr bool is_nothrow_destructible_v
  = is_nothrow_destructible&lt;T>::value;
template &lt;class T> constexpr bool has_virtual_destructor_v
  = has_virtual_destructor&lt;T>::value;

// See <cxx-ref in="cxx" to="meta.unary.prop.query"></cxx-ref>, type property queries
template &lt;class T> constexpr size_t alignment_of_v
  = alignment_of&lt;T>::value;
template &lt;class T> constexpr size_t rank_v
  = rank&lt;T>::value;
template &lt;class T, unsigned I = 0> constexpr size_t extent_v
  = extent&lt;T, I>::value;

// See <cxx-ref in="cxx" to="meta.rel"></cxx-ref>, type relations
template &lt;class T, class U> constexpr bool is_same_v
  = is_same&lt;T, U>::value;
template &lt;class Base, class Derived> constexpr bool is_base_of_v
  = is_base_of&lt;Base, Derived>::value;
template &lt;class From, class To> constexpr bool is_convertible_v
  = is_convertible&lt;From, To>::value;

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>

    </cxx-section>
  </cxx-section>

  <cxx-section id="ratio">
    <h1>Compile-time rational arithmetic</h1>

    <cxx-section id="header.ratio.synop">
      <h1>Header &lt;experimental/ratio> synopsis</h1>

<pre><code>#include &lt;ratio>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

// See <cxx-ref in="cxx" to="ratio.comparison"></cxx-ref>, ratio comparison
template &lt;class R1, class R2> constexpr bool ratio_equal_v
  = ratio_equal&lt;R1, R2>::value;
template &lt;class R1, class R2> constexpr bool ratio_not_equal_v
  = ratio_not_equal&lt;R1, R2>::value;
template &lt;class R1, class R2> constexpr bool ratio_less_v
  = ratio_less&lt;R1, R2>::value;
template &lt;class R1, class R2> constexpr bool ratio_less_equal_v
  = ratio_less_equal&lt;R1, R2>::value;
template &lt;class R1, class R2> constexpr bool ratio_greater_v
  = ratio_greater&lt;R1, R2>::value;
template &lt;class R1, class R2> constexpr bool ratio_greater_equal_v
  = ratio_greater_equal&lt;R1, R2>::value;

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="time">
    <h1>Time utilities</h1>

    <cxx-section id="header.chrono.synop">
      <h1>Header &lt;experimental/chrono> synopsis</h1>

<pre><code>#include &lt;chrono>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

// See <cxx-ref in="cxx" to="time.traits"></cxx-ref>, customization traits
template &lt;class Rep> constexpr bool treat_as_floating_point_v
  = treat_as_floating_point&lt;Rep>::value;

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>

  <cxx-section id="syserror">
    <h1>System error support</h1>

    <cxx-section id="header.system_error.synop">
      <h1>Header &lt;experimental/system_error> synopsis</h1>

<pre><code>#include &lt;system_error>

namespace std {
namespace experimental {
inline namespace fundamentals_v1 {

template &lt;class T> constexpr bool is_error_code_enum_v
  = is_error_code_enum&lt;T>::value;
template &lt;class T> constexpr bool is_error_condition_enum_v
  = is_error_condition_enum&lt;T>::value;

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>
    </cxx-section>
  </cxx-section>
</cxx-clause>
