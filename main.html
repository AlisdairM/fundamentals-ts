<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <script src="bower_components/platform/platform.js"></script>
  <link rel="import" href="bower_components/cxx-html-doc-framework/framework.html"/>
</head>
<body unresolved="">
<cxx-titlepage stage="draft">
  <cxx-docnum>D3908</cxx-docnum>
  <time pubdate="">2014-02-??</time>
  <cxx-revises><a href="http://isocpp.org/files/papers/N3848.html">N3848</a></cxx-revises>
  <cxx-editor>
    Jeffrey Yasskin<br/>
    Google, Inc.<br/>
    <cxx-email>jyasskin@google.com</cxx-email>
  </cxx-editor>
  <h1>Technical Specification on C++ Extensions for Library Fundamentals</h1>
</cxx-titlepage>

<cxx-toc></cxx-toc>

<cxx-clause id="general">
  <h1>General</h1>
  <cxx-section id="general.scope">
    <h1>Scope</h1>
    <p>This technical specification describes extensions to the C++
    Standard Library (<cxx-ref
    to="general.references"></cxx-ref>). These extensions are classes
    and functions that are likely to be used widely within a program
    and/or on the interface boundaries between libraries written by
    different organizations.</p>

    <p>This technical specification is non-normative. Some of the
    library components in this technical specification may be
    considered for standardization in a future version of C++, but
    they are not currently part of any C++ standard. Some of the
    components in this technical specification may never be
    standardized, and others may be standardized in a substantially
    changed form.</p>

    <p>The goal of this technical specification is to build more
    widespread existing practice for an expanded C++ standard
    library. It gives advice on extensions to those vendors who wish
    to provide them.</p>
  </cxx-section>

  <cxx-section id="general.references">
    <h1>Normative references</h1>

    <p>The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>

    <ul>
      <li>ISO/IEC 14882:—<cxx-footnote>To be published. Section references are relative to <a href="http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">N3797</a>.</cxx-footnote>,
      <cite>Programming Languages — C++</cite>
      <cxx-foreign-index id="cxx" src="cxx_N3797_index.json" name="C++14"></cxx-foreign-index></li>

      <li><a href="http://www.ietf.org/rfc/rfc2781.txt">RFC 2781</a>, <cite>UTF-16, an encoding of ISO 10646</cite></li>
    </ul>

    <p>ISO/IEC 14882:— is herein called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++14
    &#xa7;3.2". The library described in ISO/IEC 14882:— clauses 17–30 is
    herein called the <dfn>C++ Standard Library</dfn>.</p>

    <p>Unless otherwise specified, the whole of the C++ Standard's Library
    introduction (<cxx-ref in="cxx" to="library"></cxx-ref>) is included into this
    Technical Specification by reference.</p>
  </cxx-section>

  <cxx-section id="general.namespaces">
    <h1>Namespaces, headers, and modifications to standard classes</h1>

    <cxx-ednote>This section reflects the consensus between the LWG and LEWG at the
    <a href="http://wiki.edg.com/twiki/bin/view/Wg21chicago2013/FundamentalsTS#What_can_go_into_a_TS">Chicago 2013</a> and
    <a href="http://wiki.edg.com/twiki/bin/view/Wg21issaquah/ChangesToExistingInTS">Issaquah 2014</a> meetings.</cxx-ednote>

    <p>Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>.
    Unless otherwise specified, all components described in this technical specification that are not modifications of existing interfaces in the C++ Standard Library
    are declared in namespace <code>std::experimental::fundamentals_v1</code> or a subnamespace thereof.
    Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::fundamentals_v1</code> into
    <code>std::experimental</code> as if by</p>

    <pre><code>namespace std {
  namespace experimental {
    inline namespace fundamentals_v1 {}
  }
}</code></pre>

    <p>
      This technical specification also describes some experimental modifications to existing interfaces in the C++ Standard Library.
      These modifications are described by quoting the affected parts of the standard
      and using <ins>underlining</ins> to represent added text and <del>strike-through</del> to represent deleted text.
    </p>

    <p>Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::fundamentals_v1::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p>Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow></code> are provided inside the
    <code>&lt;experimental/meow></code> header, which shall include
    the standard contents of <code>&lt;meow></code> as if by</p>
    <pre><code>#include &lt;meow></code></pre>

    <p>New headers are also provided in the
    <code>&lt;experimental/></code> directory, but without such an
    <code>#include</code>.</p>

    <table is="cxx-table" id="tab.cxx.headers" class="list">
      <caption>C++ library headers</caption>
      <tr>
        <td><code>&lt;experimental/algorithm></code></td>
        <td><code>&lt;experimental/memory></code></td>
        <td><code>&lt;experimental/string_view></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/any></code></td>
        <td><code>&lt;experimental/memory_resource></code></td>
        <td><code>&lt;experimental/system_error></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/chrono></code></td>
        <td><code>&lt;experimental/net></code></td>
        <td><code>&lt;experimental/tuple></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/deque></code></td>
        <td><code>&lt;experimental/optional></code></td>
        <td><code>&lt;experimental/type_traits></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/forward_list></code></td>
        <td><code>&lt;experimental/ratio></code></td>
        <td><code>&lt;experimental/unordered_map></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/functional></code></td>
        <td><code>&lt;experimental/regex></code></td>
        <td><code>&lt;experimental/unordered_set></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/list></code></td>
        <td><code>&lt;experimental/set></code></td>
        <td><code>&lt;experimental/utility></code></td>
      </tr>
      <tr>
        <td><code>&lt;experimental/map></code></td>
        <td><code>&lt;experimental/string></code></td>
        <td><code>&lt;experimental/vector></code></td>
      </tr>
    </table>
  </cxx-section>

  <cxx-section id="general.defns">
    <h1>Terms and definitions</h1>

    <p>For the purposes of this document, the terms and definitions
    given in the C++ Standard and the folowing apply.</p>

    <dl is="cxx-definition-section">
      <dt id="general.defns.direct-non-list-init">direct-non-list-initialization</dt>
      <dd>A direct-initialization that is not list-initialization.</dd>
    </dl>
  </cxx-section>

  <cxx-section id="general.plans">
    <h1>Future plans (Informative)</h1>

    <p>This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p>The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::fundamentals_v2</code>,
    <code>std::experimental::fundamentals_v3</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p>When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::fundamentals_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  </cxx-section>

  <cxx-section id="general.feature.test">
    <h1>Feature-testing recommendations (Informative)</h1>

    <p>
      For the sake of improved portability between partial implementations of various C++ standards,
      WG21 (the ISO technical committee for the C++ programming language) recommends
      that implementers and programmers follow the guidelines in this section concerning feature-test macros.
      <cxx-note><a href="http://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21's SD-6</a> makes similar recommendations for the C++ Standard itself.</cxx-note>
    </p>

    <p>
      Implementers who provide a new standard feature should define a macro with the recommended name and value,
      in the same circumstances under which the feature is available (for example, taking into account relevant command-line options),
      to indicate the presence of support for that feature.
    </p>

    <p>
      Programmers who wish to determine whether a feature is available in an implementation should base that determination on the state of the macro with the recommended name.
      (The absence of a tested feature may result in a program with decreased functionality, or the relevant functionality may be provided in a different way.
      A program that strictly depends on support for a feature can just try to use the feature unconditionally;
      presumably, on an implementation lacking necessary support, translation will fail.)
    </p>

    <table is="cxx-table" class="column-rules">
      <caption>Significant features in this technical specification</caption>

      <thead>
        <tr>
          <th>Doc. No.</th>
          <th>Title</th>
          <th>Primary Section</th>
          <th>Macro Name</th>
          <th>Value</th>
          <th>Header</th>
        </tr>
      </thead>

      <tr>
        <td>N3925</td>
        <td>A <code>sample</code> Proposal</td>
        <td><cxx-ref to="alg.random.sample"></cxx-ref></td>
        <td><code>__cpp_lib_experimental_sample</code></td>
        <td>201402</td>
        <td><code>&lt;experimental/algorithm></code></td>
      </tr>
      <tr>
        <td>N3923</td>
        <td>A SFINAE-Friendly <code>iterator_traits</code></td>
        <td><cxx-ref to="mods.iterator.traits"></cxx-ref></td>
        <td><code>__cpp_lib_experimental_iterator_traits_sfinae</code></td>
        <td>201402</td>
        <td><code>&lt;iterator></code></td>
      </tr>
      <tr>
        <td>N3843</td>
        <td>A SFINAE-Friendly <code>common_type</code></td>
        <td><cxx-ref to="mods.meta.trans.other"></cxx-ref></td>
        <td><code>__cpp_lib_experimental_common_type_sfinae</code></td>
        <td>201402</td>
        <td><code>&lt;type_traits></code></td>
      </tr>
    </table>
  </cxx-section>
</cxx-clause>

<cxx-include href="mods.html"></cxx-include>
<cxx-include href="utilities.html"></cxx-include>
<cxx-include href="func.html"></cxx-include>

<cxx-clause id="optional">
  <h1>Optional objects</h1>

  <cxx-section id="optional.general">
    <h1>In general</h1>

    <p>This subclause describes class template <code>optional</code> that represents <em>optional objects</em>. An <dfn>optional object for object types</dfn> is an object that contains the storage for another object and manages the lifetime of this contained object, if any. The contained object may be initialized after the optional object has been initialized, and may be destroyed before the optional object has been destroyed. The initialization state of the contained object is tracked by the optional object.</p>
  </cxx-section>

  <cxx-section id="optional.synop">
    <h1>Header <code>&lt;experimental/optional&gt;</code> synopsis</h1>

<pre>
namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
  <cxx-ref insynopsis="" to="optional.object"></cxx-ref>
  template &lt;class T&gt; class optional;

  <cxx-ref insynopsis="" to="optional.inplace"></cxx-ref>
  struct in_place_t{};
  constexpr in_place_t in_place{};

  <cxx-ref insynopsis="" to="optional.nullopt"></cxx-ref>
  struct nullopt_t{<em>see below</em>};
  constexpr nullopt_t nullopt(<em>unspecified</em>);

  <cxx-ref insynopsis="" to="optional.bad_optional_access"></cxx-ref>
  class bad_optional_access;

  <cxx-ref insynopsis="" to="optional.relops"></cxx-ref>
  template &lt;class T&gt;
    constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt;
    constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.nullops"></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;
  template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;
  template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;

  <cxx-ref insynopsis="" to="optional.comp_with_t"></cxx-ref>
  template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator==(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator!=(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&gt;(const T&amp;, const optional&lt;T&gt;&amp;);
  template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const T&amp;);
  template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp;, const optional&lt;T&gt;&amp;);

  <cxx-ref insynopsis="" to="optional.specalg"></cxx-ref>
  template &lt;class T&gt; void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(<em>see below</em>);
  template &lt;class T&gt; constexpr optional&lt;<em>see below</em>&gt; make_optional(T&amp;&amp;);

} // <i>namespace fundamentals_v1</i>
} // <i>namespace experimental</i>

  <cxx-ref insynopsis="" to="optional.hash"></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;
} // <i>namespace std</i>
</pre>

    <p>A program that necessitates the instantiation of template <code>optional</code> for a reference type, or for possibly cv-qualified types <code>in_place_t</code> or <code>nullopt_t</code> is ill-formed.</p>
  </cxx-section>

  <cxx-section id="optional.defs">
    <h1>Definitions</h1>

    <p>An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>disengaged</dfn> if:</p>
    <ul>
      <li>it default-initialized; or</li>
      <li>it is initialized with a value of type <code>nullopt_t</code> or with a disengaged optional object of type <code>optional&lt;T&gt;</code>; or</li>
      <li>a value of type <code>nullopt_t</code> or a disengaged optional object of type <code>optional&lt;T&gt;</code> is assigned to it.</li>
    </ul>


    <p>An instance of <code>optional&lt;T&gt;</code> is said to be <dfn>engaged</dfn> if it is not disengaged.
    </p>
  </cxx-section>

  <cxx-section id="optional.object">
    <h1><code>optional</code> for object types</h1>

<pre>template &lt;class T&gt;
class optional
{
public:
  typedef T value_type;

  <cxx-ref insynopsis="" to="optional.object.ctor"></cxx-ref>
  constexpr optional() noexcept;
  constexpr optional(nullopt_t) noexcept;
  optional(const optional&amp;);
  optional(optional&amp;&amp;) noexcept(<em>see below</em>);
  constexpr optional(const T&amp;);
  constexpr optional(T&amp;&amp;);
  template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    constexpr explicit optional(in_place_t, initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.dtor"></cxx-ref>
  ~optional();

  <cxx-ref insynopsis="" to="optional.object.assign"></cxx-ref>
  optional&amp; operator=(nullopt_t) noexcept;
  optional&amp; operator=(const optional&amp;);
  optional&amp; operator=(optional&amp;&amp;) noexcept(<em>see below</em>);
  template &lt;class U&gt; optional&amp; operator=(U&amp;&amp;);
  template &lt;class... Args&gt; void emplace(Args&amp;&amp;...);
  template &lt;class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);

  <cxx-ref insynopsis="" to="optional.object.swap"></cxx-ref>
  void swap(optional&amp;) noexcept(<em>see below</em>);

  <cxx-ref insynopsis="" to="optional.object.observe"></cxx-ref>
  constexpr T const* operator -&gt;() const;
  T* operator -&gt;();
  constexpr T const&amp; operator *() const;
  T&amp; operator *();
  constexpr explicit operator bool() const noexcept;
  constexpr T const&amp; value() const;
  T&amp; value();
  template &lt;class U&gt; constexpr T value_or(U&amp;&amp;) const&amp;;
  template &lt;class U&gt; T value_or(U&amp;&amp;) &amp;&amp;;

private:
  bool init; // <i>exposition only</i>
  T*   val;  // <i>exposition only</i>
};</pre>

    <p>Engaged instances of <code>optional&lt;T&gt;</code> where <code>T</code> is of object type shall contain a value of type <code>T</code> within its own storage. This value is referred to as the <dfn>contained value</dfn> of the optional object. Implementations are not permitted to use additional storage, such as dynamic memory, to allocate its contained value.  The contained value shall be allocated in a region of the <code>optional&lt;T&gt;</code> storage suitably aligned for the type <code>T</code>.</p>

    <p>
      Members <code><var>init</var></code> and <code><var>val</var></code> are provided for exposition only.
      Implementations need not provide those members.
      <code><var>init</var></code> indicates whether the <code>optional</code> object's contained value has been initialized (and not yet destroyed);
      when <code><var>init</var></code> is true,
      <code><var>val</var></code> points to the contained value.
    </p>

    <p><code>T</code> shall be an object type and shall satisfy the requirements of <code>Destructible</code> (Table 24).</p>

    <cxx-section id="optional.object.ctor">
      <h1>Constructors</h1>

      <cxx-function>
        <cxx-signature>constexpr optional() noexcept;</cxx-signature>
        <cxx-signature>constexpr optional(nullopt_t) noexcept;</cxx-signature>

        <cxx-postconditions><code>*this</code> is disengaged.</cxx-postconditions>
        <cxx-remarks>No contained value is initialized.
        For every object type <code>T</code> these constructors shall be <code>constexpr</code> constructors (<cxx-ref in="cxx" to="dcl.constexpr"></cxx-ref>).</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>optional(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature>

        <cxx-requires><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>If <code><var>rhs</var></code> is engaged initializes the contained value as if
        direct-non-list-initializing an object of type <code>T</code> with the expression <code>*<var>rhs</var></code>.</cxx-effects>
        <cxx-postconditions><code>bool(<var>rhs</var>) == bool(*this)</code>.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature>optional(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature>

        <cxx-requires><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>If <code><var>rhs</var></code> is engaged initializes the contained value as if
        direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(*<var>rhs</var>)</code>.
        <code>bool(<var>rhs</var>)</code> is unchanged.</cxx-effects>
        <cxx-postconditions><code>bool(<var>rhs</var>) == bool(*this)</code>.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-remarks>The expression inside <code>noexcept</code> is equivalent to:<pre>is_nothrow_move_constructible&lt;T&gt;::value</pre></cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr optional(const T&amp; <var>v</var>);</cxx-signature>

        <cxx-requires><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code><var>v</var></code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-remarks>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr optional(T&amp;&amp; <var>v</var>);</cxx-signature>

        <cxx-requires><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the expression <code>std::move(<var>v</var>)</code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-remarks>If <code>T</code>'s selected constructor is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class... Args&gt; constexpr explicit optional(in_place_t, Args&amp;&amp;... <var>args</var>);</cxx-signature>

        <cxx-requires><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-remarks>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U, class... Args&gt; <wbr/>constexpr explicit optional(in_place_t, initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature>

        <cxx-requires><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-remarks>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-remarks>
        <cxx-remarks>If <code>T</code>'s constructor selected for the initialization is a <code>constexpr</code> constructor, this constructor shall be a <code>constexpr</code> constructor.</cxx-remarks>
      </cxx-function>
    </cxx-section>

    <cxx-section id="optional.object.dtor">
      <h1>Destructor</h1>

      <cxx-function>
        <cxx-signature>~optional();</cxx-signature>

        <cxx-effects>If <code>is_trivially_destructible&lt;T&gt;::value != true</code> and <code>*this</code> is engaged, calls <code><var>val</var>-&gt;T::~T()</code>.</cxx-effects>
        <cxx-remarks>If <code>is_trivially_destructible&lt;T&gt;::value == true</code> then this destructor shall be a trivial destructor.</cxx-remarks>
      </cxx-function>
    </cxx-section>

    <cxx-section id="optional.object.assign">
      <h1>Assignment</h1>

      <cxx-function>
        <cxx-signature>optional&lt;T&gt;&amp; operator=(nullopt_t) noexcept;</cxx-signature>

        <cxx-effects>If <code>*this</code> is engaged calls <code><var>val</var>-&gt;T::~T()</code> to destroy the contained value; otherwise no effect.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
        <cxx-postconditions><code>*this</code> is disengaged.</cxx-postconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>optional&lt;T&gt;&amp; operator=(const optional&lt;T&gt;&amp; <var>rhs</var>);</cxx-signature>

        <cxx-requires><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_copy_assignable&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>*<var>rhs</var></code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>*<var>rhs</var></code> to the contained value.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
        <cxx-postconditions><code>bool(<var>rhs</var>) == bool(*this)</code>.</cxx-postconditions>
        <cxx-exception-safety>
          If any exception is thrown, the values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged.
          If an exception is thrown during the call to <code>T</code>'s copy constructor, no effect.
          If an exception is thrown during the call to <code>T</code>'s copy assignment,
          the state of its contained value is as defined by the exception safety guarantee of <code>T</code>'s copy assignment.
        </cxx-exception-safety>
      </cxx-function>

      <cxx-function>
        <cxx-signature>optional&lt;T&gt;&amp; operator=(optional&lt;T&gt;&amp;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature>

        <cxx-requires><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_move_assignable&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, destroys the contained value by calling <code><var>val</var>-&gt;T::~T()</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with <code>std::move(*<var>rhs</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) assigns <code>std::move(*<var>rhs</var>)</code> to the contained value.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
        <cxx-postconditions><code>bool(<var>rhs</var>) == bool(*this)</code>.</cxx-postconditions>
        <cxx-remarks>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_assignable&lt;T&gt;::value &amp;&amp; is_nothrow_move_constructible&lt;T&gt;::value</pre></cxx-remarks>
        <cxx-exception-safety>
          If any exception is thrown, the values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged.
          If an exception is thrown during the call to <code>T</code>'s move constructor,
          the state of <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor.
          If an exception is thrown during the call to <code>T</code>'s move assignment,
          the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move assignment.
        </cxx-exception-safety>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt; optional&lt;T&gt;&amp; operator=(U&amp;&amp; <var>v</var>);</cxx-signature>

        <cxx-requires><code>is_constructible&lt;T, U&gt;::value</code> is <code>true</code> and <code>is_assignable&lt;T&amp;, U&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>If <code>*this</code> is engaged assigns <code>std::forward&lt;U&gt;(<var>v</var>)</code> to the contained value; otherwise initializes the contained value as if direct-non-list-initializing object of type <code>T</code> with <code>std::forward&lt;U&gt;(<var>v</var>)</code>.</cxx-effects>
        <cxx-returns><code>*this</code>.</cxx-returns>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-exception-safety>If any exception is thrown, the value of <code><var>init</var></code> remains unchanged. If an exception is thrown during the call to <code>T</code>'s constructor, the state of <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s constructor. If an exception is thrown during the call to <code>T</code>'s assignment, the state of <code><var>*val</var></code> and <code><var>v</var></code> is determined by the exception safety guarantee of <code>T</code>'s assignment.</cxx-exception-safety>
        <cxx-remarks>The function shall not participate in overload resolution unless
        <code>is_same&lt;typename decay&lt;U&gt;::type, T&gt;::value</code> is <code>true</code>.</cxx-remarks>
        <cxx-notes>The reason for providing such generic assignment and then constraining it so that effectively <code>T</code> == <code>U</code> is to guarantee that assignment of the form <code>o = {}</code> is unambiguous.</cxx-notes>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class... Args&gt; void emplace(Args&amp;&amp;... <var>args</var>);</cxx-signature>

        <cxx-requires><code>is_constructible&lt;T, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code>std::forward&lt;Args&gt;(<var>args</var>)...</code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-exception-safety>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> is disengaged, and the previous <code><var>*val</var></code> (if any) has been destroyed.</cxx-exception-safety>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U, class... Args&gt; <wbr/>void emplace(initializer_list&lt;U&gt; <var>il</var>, Args&amp;&amp;... <var>args</var>);</cxx-signature>

        <cxx-requires><code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>Calls <code>*this = nullopt</code>. Then initializes the contained value as if constructing an object of type <code>T</code> with the arguments <code><var>il</var>, std::forward&lt;Args&gt;(<var>args</var>)...</code>.</cxx-effects>
        <cxx-postconditions><code>*this</code> is engaged.</cxx-postconditions>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-exception-safety>If an exception is thrown during the call to <code>T</code>'s constructor, <code>*this</code> is disengaged, and the previous <code><var>*val</var></code> (if any) has been destroyed.</cxx-exception-safety>
        <cxx-remarks>The function shall not participate in overload resolution unless <code>is_constructible&lt;T, initializer_list&lt;U&gt;&amp;, Args&amp;&amp;...&gt;::value</code> is <code>true</code>.</cxx-remarks>
      </cxx-function>
    </cxx-section>

    <cxx-section id="optional.object.swap">
      <h1>Swap</h1>

      <cxx-function>
        <cxx-signature>void swap(optional&lt;T&gt;&amp; <var>rhs</var>) noexcept(<em>see below</em>);</cxx-signature>

        <cxx-requires>LValues of type T shall be swappable and <code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-effects>
          <ul>
            <li>If <code>*this</code> is disengaged and <code><var>rhs</var></code> is disengaged, no effect, otherwise</li>
            <li>if <code>*this</code> is engaged and <code><var>rhs</var></code> is disengaged, initializes the contained value of <code><var>rhs</var></code> by direct-initialization with <code>std::move(*(*this))</code>, followed by <code>val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>if <code>*this</code> is disengaged and <code><var>rhs</var></code> is engaged, initializes the contained value of <code>*this</code> by direct-initialization with <code>std::move(*<var>rhs</var>)</code>, followed by <code>rhs.val-&gt;T::~T(), swap(<var>init</var>, <var>rhs.init</var>)</code>, otherwise</li>
            <li>(if both <code>*this</code> and <code><var>rhs</var></code> are engaged) calls <code>swap(*(*this), *<var>rhs</var>)</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-throws>Any exceptions that the expressions in the Effects clause throw.</cxx-throws>
        <cxx-remarks>The expression inside <code>noexcept</code> is equivalent to: <pre>is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; <wbr/>noexcept(swap(declval&lt;T&amp;&gt;(), declval&lt;T&amp;&gt;()))</pre></cxx-remarks>
        <cxx-exception-safety>
          If any exception is thrown, the values of <code><var>init</var></code> and <code><var>rhs.init</var></code> remain unchanged.
          If an exception is thrown during the call to function <code>swap</code>
          the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>swap</code> for lvalues of <code>T</code>.
          If an exception is thrown during the call to <code>T</code>'s move constructor,
          the state of <code><var>*val</var></code> and <code>*rhs.val</code> is determined by the exception safety guarantee of <code>T</code>'s move constructor.
        </cxx-exception-safety>
      </cxx-function>
    </cxx-section>

    <cxx-section id="optional.object.observe">
      <h1>Observers</h1>

      <cxx-function>
        <cxx-signature>constexpr T const* operator-&gt;() const;</cxx-signature>
        <cxx-signature>T* operator-&gt;();</cxx-signature>

        <cxx-requires><code>*this</code> is engaged.</cxx-requires>
        <cxx-returns><code><var>val</var></code>.</cxx-returns>
        <cxx-throws>Nothing.</cxx-throws>
        <cxx-remarks>Unless <code>T</code> is a user-defined type with overloaded unary <code>operator&amp;</code>, the first function shall be a <code>constexpr</code> function.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr T const&amp; operator*() const;</cxx-signature>
        <cxx-signature>T&amp; operator*();</cxx-signature>

        <cxx-requires><code>*this</code> is engaged.</cxx-requires>
        <cxx-returns><code>*<var>val</var></code>.</cxx-returns>
        <cxx-throws>Nothing.</cxx-throws>
        <cxx-remarks>The first function shall be a <code>constexpr</code> function.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr explicit operator bool() noexcept;</cxx-signature>

        <cxx-returns><code><var>init</var></code>.</cxx-returns>
        <cxx-remarks>This function shall be a <code>constexpr</code> function.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr T const&amp; value() const;</cxx-signature>
        <cxx-signature>T&amp; value();</cxx-signature>

        <cxx-returns><code><var>*val</var></code>, if <code>bool(*this)</code>.</cxx-returns>
        <cxx-throws><code>bad_optional_access</code> if <code>!*this</code>.</cxx-throws>
        <cxx-remarks>The first function shall be a <code>constexpr</code> function.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt; constexpr T value_or(U&amp;&amp; <var>v</var>) const&amp;;</cxx-signature>

        <cxx-requires><code>is_copy_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-returns><code>bool(*this) ? **this : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</cxx-returns>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-exception-safety>If <code><var>init</var> == true</code> and exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>init</var></code> and <code><var>v</var></code> remains unchanged and the state of <code><var>*val</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>. Otherwise, when exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>*this</var></code> remains unchanged and the state of <code><var>v</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>.</cxx-exception-safety>
        <cxx-remarks>If the selected constructor of <code>T</code> is a <code>constexpr</code> constructor, this function shall be a <code>constexpr</code> function.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class U&gt; T value_or(U&amp;&amp; <var>v</var>) &amp;&amp;;</cxx-signature>

        <cxx-requires><code>is_move_constructible&lt;T&gt;::value</code> is <code>true</code> and <code>is_convertible&lt;U&amp;&amp;, T&gt;::value</code> is <code>true</code>.</cxx-requires>
        <cxx-returns><code>bool(*this) ? std::move(**this) : static_cast&lt;T&gt;(std::forward&lt;U&gt;(<var>v</var>))</code>.</cxx-returns>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
        <cxx-exception-safety>If <code><var>init</var> == true</code> and exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>init</var></code> and <code><var>v</var></code> remains unchanged and the state of <code><var>*val</var></code> is determined by the exception safety guarantee of the <code>T</code>'s constructor. Otherwise, when exception is thrown during the call to <code>T</code>'s constructor, the value of <code><var>*this</var></code> remains unchanged and the state of <code><var>v</var></code> is determined by the exception safety guarantee of the selected constructor of <code>T</code>.</cxx-exception-safety>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="optional.inplace">
    <h1>In-place construction</h1>

    <cxx-function>
      <cxx-signature>struct in_place_t{};</cxx-signature>
      <cxx-signature>constexpr in_place_t in_place{};</cxx-signature>
    </cxx-function>

    <p>The struct <code>in_place_t</code> is an empty structure type used as a unique type to disambiguate constructor and function overloading. Specifically, <code>optional&lt;T&gt;</code> has a constructor with <code>in_place_t</code> as the first argument followed by an argument pack; this indicates that <code>T</code> should be constructed in-place (as if by a call to placement new expression) with the forwarded argument pack as parameters.
    </p>
  </cxx-section>

  <cxx-section id="optional.nullopt">
    <h1>Disengaged state indicator</h1>

    <cxx-function>
      <cxx-signature>struct nullopt_t{<em>see below</em>};</cxx-signature>
      <cxx-signature>constexpr nullopt_t nullopt(<em>unspecified</em>);</cxx-signature>
    </cxx-function>

    <p>The struct <code>nullopt_t</code> is an empty structure type used as a unique type to indicate a disengaged state for <code>optional</code> objects. In particular, <code>optional&lt;T&gt;</code> has a constructor with <code>nullopt_t</code> as single argument; this indicates that a disengaged optional object shall be constructed.
    </p>

    <p>Type <code>nullopt_t</code> shall not have a default constructor. It shall be a literal type. Constant <code>nullopt</code> shall be initialized with an argument of literal type.</p>
  </cxx-section>

  <cxx-section id="optional.bad_optional_access">
    <h1>Class <code>bad_optional_access</code></h1>

<pre>class bad_optional_access : public logic_error {
public:
  explicit bad_optional_access(const string&amp; <var>what_arg</var>);
  explicit bad_optional_access(const char* <var>what_arg</var>);
};</pre>

    <p>The class <code>bad_optional_access</code> defines the type of objects thrown as exceptions to report the situation where an attempt is made to access the value of a disengaged optional object.</p>

    <cxx-function>
      <cxx-signature>bad_optional_access(const string&amp; <var>what_arg</var>);</cxx-signature>

      <cxx-effects>Constructs an object of class <code>bad_optional_access</code>.</cxx-effects>
      <cxx-postcondition><code>strcmp(what(), <var>what_arg</var>.c_str()) == 0</code>.</cxx-postcondition>
    </cxx-function>

    <cxx-function>
      <cxx-signature>bad_optional_access(const char* <var>what_arg</var>);</cxx-signature>

      <cxx-effects>Constructs an object of class <code>bad_optional_access</code>.</cxx-effects>
      <cxx-postcondition><code>strcmp(what(), <var>what_arg</var>) == 0</code>.</cxx-postcondition>
    </cxx-function>
  </cxx-section>

  <cxx-section id="optional.relops">
    <h1>Relational operators</h1>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature>

      <cxx-requires><code>T</code> shall meet the requirements of <code>EqualityComparable</code>.</cxx-requires>
      <cxx-returns>If <code>bool(<var>x</var>) != bool(<var>y</var>)</code>, <code>false</code>; otherwise if <code>bool(<var>x</var>) == false</code>, <code>true</code>; otherwise <code>*<var>x</var> == *<var>y</var></code>.</cxx-returns>
      <cxx-remarks>Instantiations of this function template for which <code>*<var>x</var> == *<var>y</var></code> is a core constant expression, shall be <code>constexpr</code> functions.</cxx-remarks>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature>
      <cxx-returns><code>!(x == y)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const optional&lt;T&gt;&amp; <var>y</var>);</cxx-signature>

      <cxx-requires>Expression <code>*<var>x</var> &lt; *<var>y</var></code> shall be well-formed
      and its result shall be convertible to <code>bool</code>.</cxx-requires>
      <cxx-returns>If <code>(!<var>y</var>)</code>, <code>false</code>;
      otherwise, if <code>(!<var>x</var>)</code>, <code>true</code>;
      otherwise <code>*<var>x</var> &lt; *<var>y</var></code>.</cxx-returns>
      <cxx-remarks>Instantiations of this function template for which the expression <code>*<var>x</var> &lt; *<var>y</var></code> is a core constant expression,
      shall be <code>constexpr</code> functions.</cxx-remarks>
    </cxx-function>


    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature>
      <cxx-returns><code>y &lt; x</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature>
      <cxx-returns><code>!(y &lt; x)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;T&gt;&amp; y);</cxx-signature>
      <cxx-returns><code>!(x &lt; y)</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="optional.nullops">
    <h1>Comparison with <code>nullopt</code></h1>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature>

      <cxx-returns><code>(!<var>x</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</cxx-signature>

      <cxx-returns><code>bool(<var>x</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>

      <cxx-returns><code>false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature>

      <cxx-returns><code>bool(<var>x</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>
      <cxx-returns><code>!<var>x</var></code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature>
      <cxx-returns><code>true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature>
      <cxx-returns><code>false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; <var>x</var>, nullopt_t) noexcept;</cxx-signature>
      <cxx-returns><code>true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp; <var>x</var>) noexcept;</cxx-signature>
      <cxx-returns><code>!<var>x</var></code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="optional.comp_with_t">
    <h1>Comparison with <code>T</code></h1>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>

      <cxx-returns><code>bool(<var>x</var>) ? *<var>x</var> == <var>v</var> : false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator==(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature>

      <cxx-returns><code>bool(<var>x</var>) ? <var>v</var> == *<var>x</var> : false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>) ? !(*<var>x</var> == <var>v</var>) : true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator!=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>) ? !(<var>v</var> == *<var>x</var>) : true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>

      <cxx-returns><code>bool(<var>x</var>) ? *<var>x</var> &lt; <var>v</var> : true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; <var>x</var>);</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>) ? <var>v</var> &lt; *<var>x</var> : false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>) ? *<var>x</var> &lt; <var>v</var> : true</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>
      <cxx-returns><code>bool(<var>x</var>) ? <var>v</var> &lt; *<var>x</var> : false</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>
      <cxx-returns><code>!(<var>x</var> &lt; <var>v</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&gt;=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature>
      <cxx-returns><code>!(<var>v</var> &lt; <var>x</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; <var>x</var>, const T&amp; <var>v</var>);</cxx-signature>
      <cxx-returns><code>!(<var>x</var> &gt; <var>v</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr bool operator&lt;=(const T&amp; <var>v</var>, const optional&lt;T&gt;&amp; x);</cxx-signature>
      <cxx-returns><code>!(<var>v</var> &gt; <var>x</var>)</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="optional.specalg">
    <h1>Specialized algorithms</h1>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; void swap(optional&lt;T&gt;&amp; <var>x</var>, optional&lt;T&gt;&amp; <var>y</var>) noexcept(noexcept(<var>x</var>.swap(<var>y</var>)));</cxx-signature>

      <cxx-effects>calls <code><var>x</var>.swap(<var>y</var>)</code>.</cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; constexpr optional&lt;typename decay&lt;T&gt;::type&gt; make_optional(T&amp;&amp; <var>v</var>);</cxx-signature>

      <cxx-returns><code>optional&lt;typename decay&lt;T&gt;::type&gt;(std::forward&lt;T&gt;(<var>v</var>))</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="optional.hash">
    <h1>Hash support</h1>

    <cxx-function>
      <cxx-signature>template &lt;class T&gt; struct hash&lt;experimental::optional&lt;T&gt;&gt;;</cxx-signature>

      <cxx-requires>the template specialization <code>hash&lt;T&gt;</code> shall meet the requirements of class template <code>hash</code> (<cxx-ref in="cxx" to="unord.hash"></cxx-ref>).
      The template specialization <code>hash&lt;optional&lt;T&gt;&gt;</code> shall meet the requirements of class template <code>hash</code>.
      For an object <code><var>o</var></code> of type <code>optional&lt;T&gt;</code>, if <code>bool(<var>o</var>) == true</code>,
      <code>hash&lt;optional&lt;T&gt;&gt;()(<var>o</var>)</code> shall evaluate to the same value as <code>hash&lt;T&gt;()(*<var>o</var>)</code>;
      otherwise it evaluates to an unspecified value.</cxx-requires>
    </cxx-function>
  </cxx-section>
</cxx-clause>

<cxx-clause id="any">
  <h1>Class <code>any</code></h1>

  <p>
    This section describes components that C++ programs may use to perform operations on objects of a discriminated type.
  </p>

  <p>
    <cxx-note>The discriminated type may contain values of different types but does not attempt conversion between them,
    i.e. <code>5</code> is held strictly as an <code>int</code> and is not implicitly convertible either to <code>&quot;5&quot;</code> or to <code>5.0</code>.
    This indifference to interpretation but awareness of type effectively allows safe, generic containers of single values, with no scope for surprises from ambiguous conversions.</cxx-note>
  </p>

  <cxx-section id="any.synop">
    <h1>Header &lt;experimental/any&gt; synopsis</h1>

    <pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
class bad_any_cast : public bad_cast
{
public:
  virtual const char* what() const noexcept;
};

class any
{
public:
  <cxx-ref insynopsis="" to="any.cons"></cxx-ref>
  any() noexcept;

  any(const any&amp; other);
  any(any&amp;&amp; x) noexcept;

  template &lt;typename ValueType&gt;
    any(ValueType&amp;&amp; value);

  template &lt;class Allocator&gt;
    any(allocator_arg_t, const Allocator&amp; a) noexcept;
  template &lt;class Allocator, typename ValueType&gt;
    any(allocator_arg_t, const Allocator&amp; a, ValueType&amp;&amp; value);
  template &lt;class Allocator&gt;
      any(allocator_arg_t, const Allocator&amp; a, const any&amp; other);
  template &lt;class Allocator&gt;
      any(allocator_arg_t, const Allocator&amp; a, any&amp;&amp; other) noexcept;

  ~any();

  <cxx-ref insynopsis="" to="any.assign"></cxx-ref>
  any&amp; operator=(const any&amp; rhs);
  any&amp; operator=(any&amp;&amp; rhs) noexcept;

  template &lt;typename ValueType&gt;
    any&amp; operator=(ValueType&amp;&amp; rhs);

  <cxx-ref insynopsis="" to="any.modifiers"></cxx-ref>
  void clear() noexcept;
  void swap(any&amp; rhs) noexcept;

  <cxx-ref insynopsis="" to="any.observers"></cxx-ref>
  bool empty() const noexcept;
  const type_info&amp; type() const noexcept;
};

<cxx-ref insynopsis="" to="any.nonmembers"></cxx-ref>
void swap(any&amp; x, any&amp; y) noexcept;

template&lt;typename ValueType&gt;
  ValueType any_cast(const any&amp; operand);
template&lt;typename ValueType&gt;
  ValueType any_cast(any&amp; operand);
template&lt;typename ValueType&gt;
  ValueType any_cast(any&amp;&amp; operand);

template&lt;typename ValueType&gt;
  const ValueType* any_cast(const any* operand) noexcept;
template&lt;typename ValueType&gt;
  ValueType* any_cast(any* operand) noexcept;
}
}
}</code></pre>
  </cxx-section>

  <cxx-section id="any.bad_any_cast">
    <h1>Class <code>bad_any_cast</code></h1>
    <p>
      Objects of type <code>bad_any_cast</code> are thrown by a failed <code> any_cast</code>.
    </p>
  </cxx-section>

  <cxx-section id="any.class">
    <h1>Class <code>any</code></h1>

    <p>
      An object of class <code>any</code> stores an instance of any type that satisfies the constructor requirements or is empty,
      and this is referred to as the <dfn>state</dfn> of the class <code>any</code> object.
      The stored instance is called the <dfn>contained object</dfn>.
      Two states are equivalent if they are either both empty or if both are not empty and if the contained objects are equivalent.
    </p>

    <p>
      The non-member <code>any_cast</code> functions provide type-safe access to the contained object.
    </p>

    <p>
      Implementations should avoid the use of dynamically allocated memory for a small contained object.
      <cxx-example class="inline">where the object constructed is holding only an int.</cxx-example>
      Such small-object optimization shall only be applied to nothrow copyable types.
    </p>

    <cxx-section id="any.cons">
      <h1><code>any</code> construct/destruct</h1>

      <cxx-function>
        <cxx-signature>any() noexcept;</cxx-signature>

        <cxx-postconditions><code>this-&gt;empty()</code></cxx-postconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>any(const any&amp; other);</cxx-signature>

        <cxx-effects>Constructs an object of type <code>any</code> with an equivalent state as <code>other</code>.</cxx-effects>
        <cxx-throws>Any exceptions arising from the copy constructor of the contained object.</cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature>any(any&amp;&amp; other) noexcept;</cxx-signature>

        <cxx-effects>Constructs an object of type <code>any</code> with a state equivalent to the original state of <code>other</code>.</cxx-effects>
        <cxx-postconditions><code>other</code> is left in a valid but otherwise unspecified state.</cxx-postconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template&lt;typename ValueType&gt;
any(ValueType&amp;&amp; value);</cxx-signature>

        <p>Let <code>T</code> be equal to <code>decay&lt;<wbr />ValueType&gt;::type</code>.</p>
        <cxx-requires><code>T</code> shall satisfy the CopyConstructible requirements.
        If <code>is_copy_constructible&lt;T&gt;::value</code> is false, the program is ill-formed.</cxx-requires>
        <cxx-effects>Constructs an object of type <code>any</code> that contains an object of type <code>T</code> direct-initialized with <code>std::forward&lt;ValueType&gt;(value)</code>.</cxx-effects>
        <cxx-remarks>This constructor shall not participate in overload resolution if <code>decay&lt;ValueType&gt;::type</code> is the same type as <code>any</code>.</cxx-remarks>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template &lt;class Allocator&gt;
any(allocator_arg_t, const Allocator&amp; a) noexcept;</cxx-signature>
        <cxx-signature>template &lt;class Allocator, typename ValueType&gt;
any(allocator_arg_t, const Allocator&amp; a, ValueType&amp;&amp; value);</cxx-signature>
        <cxx-signature>template &lt;class Allocator&gt;
any(allocator_arg_t, const Allocator&amp; a, const any&amp; other);</cxx-signature>
        <cxx-signature>template &lt;class Allocator&gt;
any(allocator_arg_t, const Allocator&amp; a, any&amp;&amp; other) noexcept;</cxx-signature>

        <cxx-requires><code>Allocator</code> shall meet the requirements for an Allocator (<cxx-ref in="cxx" to="allocator.requirements"></cxx-ref>).</cxx-requires>
        <cxx-effects>Equivalent to the preceding constructors except that the contained object is constructed with uses-allocator construction (<cxx-ref in="cxx" to="allocator.uses.construction"></cxx-ref>) if memory allocation is performed.</cxx-effects>
      </cxx-function>

      <cxx-function>
        <cxx-signature>~any();</cxx-signature>

        <cxx-effects><code>clear()</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="any.assign">
      <h1><code>any</code> assignments</h1>

      <cxx-function>
        <cxx-signature>any&amp; operator=(const any&amp; rhs);</cxx-signature>

        <cxx-effects><code>any(rhs).swap(*this)</code>.
        No effects if an exception is thrown.</cxx-effects>
        <cxx-returns><code>*this</code></cxx-returns>
        <cxx-throws>Any exceptions arising from the copy constructor of the contained object.</cxx-throws>
      </cxx-function>

      <cxx-function>
        <cxx-signature>any&amp; operator=(any&amp;&amp; rhs) noexcept;</cxx-signature>

        <cxx-effects><code>any(std::move(rhs)).swap(*this)</code>.</cxx-effects>
        <cxx-returns><code>*this</code></cxx-returns>
        <cxx-postconditions>The state of <code>*this</code> is equivalent to the original state of <code>rhs</code>
        and <code>rhs</code> is left in a valid but otherwise unspecified state.</cxx-postconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>template&lt;typename ValueType&gt;
any&amp; operator=(ValueType&amp;&amp; rhs);</cxx-signature>

        <p>Let <code>T</code> be equal to <code>decay&lt;<wbr />ValueType&gt;::type</code>.</p>
        <cxx-requires><code>T</code> shall satisfy the CopyConstructible requirements.
        If <code>is_copy_constructible&lt;T&gt;::value</code> is false, the program is ill-formed.</cxx-requires>
        <cxx-effects>Constructs an object <code>tmp</code> of type <code>any</code> that contains an object of type <code>T</code> direct-initialized with <code>std::forward&lt;ValueType&gt;(rhs)</code>, and <code>tmp.swap(*this)</code>.
        No effects if an exception is thrown.</cxx-effects>
        <cxx-returns><code>*this</code></cxx-returns>
        <cxx-remarks> This operator shall not participate in overload resolution if <code>decay&lt;ValueType&gt;::type</code> is the same type as <code>any</code>.</cxx-remarks>
        <cxx-throws>Any exception thrown by the selected constructor of <code>T</code>.</cxx-throws>
      </cxx-function>
    </cxx-section>

    <cxx-section id="any.modifiers">
      <h1><code>any</code> modifiers</h1>

      <cxx-function>
        <cxx-signature>void clear() noexcept;</cxx-signature>

        <cxx-effects>If not empty, destroys the contained object.</cxx-effects>
        <cxx-postconditions><code>empty() == true</code>.</cxx-postconditions>
      </cxx-function>

      <cxx-function>
        <cxx-signature>void swap(any&amp; rhs) noexcept;</cxx-signature>

        <cxx-effects>Exchange the states of <code>*this</code> and <code> rhs</code>.</cxx-effects>
      </cxx-function>
    </cxx-section>

    <cxx-section id="any.observers">
      <h1><code>any</code> observers</h1>

      <cxx-function>
        <cxx-signature>bool empty() const noexcept;</cxx-signature>

        <cxx-returns><code>true</code> if <code>*this</code> has no contained object, otherwise <code> false</code>.</cxx-returns>
      </cxx-function>

      <cxx-function>
        <cxx-signature>const type_info&amp; type() const noexcept;</cxx-signature>

        <cxx-returns>If <code>*this</code> has a contained object of type T, <code>typeid(T)</code>;
        otherwise <code>typeid(void)</code>.</cxx-returns>
        <p><cxx-note>Useful for querying against types known either at compile time or only at runtime.</cxx-note></p>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="any.nonmembers">
    <h1><a name="Non-member">Non-member</a> functions</h1>

    <cxx-function>
      <cxx-signature>void swap(any&amp; x, any&amp; y) noexcept;</cxx-signature>

      <cxx-effects><code>x.swap(y)</code>.</cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;typename ValueType&gt;
ValueType any_cast(const any&amp; operand);</cxx-signature>
      <cxx-signature>template&lt;typename ValueType&gt;
ValueType any_cast(any&amp; operand);</cxx-signature>
      <cxx-signature>template&lt;typename ValueType&gt;
ValueType any_cast(any&amp;&amp; operand);</cxx-signature>

      <cxx-requires><code>is_reference&lt;ValueType&gt;::value</code> is true or <code>is_copy_constructible&lt;ValueType&gt;::value</code> is true.
      Otherwise the program is ill-formed.</cxx-requires>
      <cxx-returns>For the first form, <code>*any_cast&lt;typename add_const&lt;typename remove_reference&lt;ValueType&gt;::type&gt;::type &gt;(&amp;operand)</code>.
      For the second and third forms, <code>*any_cast&lt;typename remove_reference&lt;ValueType&gt;::type&gt;(&amp;operand)</code>.</cxx-returns>
      <cxx-throws><code>bad_any_cast</code> if <code>operand.type() != typeid(remove_reference&lt;ValueType&gt;::type)</code>.</cxx-throws>
      <cxx-example>
        <pre>any x(5);                                   // x holds int
assert(any_cast&lt;int&gt;(x) == 5);              // cast to value
any_cast&lt;int&amp;&gt;(x) = 10;                     // cast to reference
assert(any_cast&lt;int&gt;(x) == 10);

x = &quot;Meow&quot;;                                 // x holds const char*
assert(strcmp(any_cast&lt;const char*&gt;(x), &quot;Meow&quot;) == 0);
any_cast&lt;const char*&amp;&gt;(x) = &quot;Harry&quot;;
assert(strcmp(any_cast&lt;const char*&gt;(x), &quot;Harry&quot;) == 0);

x = string(&quot;Meow&quot;);                         // x holds string
string s, s2(&quot;Jane&quot;);
s = move(any_cast&lt;string&amp;&gt;(x));             // move from any
assert(s == &quot;Meow&quot;);
any_cast&lt;string&amp;&gt;(x) = move(s2);            // move to any
assert(any_cast&lt;const string&amp;&gt;(x) == &quot;Jane&quot;);

string cat(&quot;Meow&quot;);
const any y(cat);                           // const y holds string
assert(any_cast&lt;const string&amp;&gt;(y) == cat);

any_cast&lt;string&amp;&gt;(y);                       // error; cannot
                                            //  any_cast away const</pre>
      </cxx-example>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;typename ValueType&gt;
const ValueType* any_cast(const any* operand) noexcept;</cxx-signature>
      <cxx-signature>template&lt;typename ValueType&gt;
ValueType* any_cast(any* operand) noexcept;</cxx-signature>

      <cxx-returns>If <code>operand != nullptr &amp;&amp; operand-&gt;type() == typeid(ValueType)</code>,
      a pointer to the object contained by <code>operand</code>,
      otherwise <code>nullptr</code>.</cxx-returns>
      <cxx-example>
        <pre>bool is_string(const any&amp; operand) {
  return any_cast&lt;string&gt;(&amp;operand) != nullptr;
}</pre>
      </cxx-example>
    </cxx-function>
  </cxx-section>
</cxx-clause>

<cxx-clause id="string.view">
  <h1><code>string_view</code></h1>

  <p>
    The class template <code>basic_string_view</code> describes an object that can refer to a constant contiguous sequence of char-like (<cxx-ref in="cxx" to="strings.general"></cxx-ref>) objects with the first element of the sequence at position zero.
    In the rest of this section, the type of the char-like objects held in a <code>basic_string_view</code> object is designated by <code>charT</code>.
  </p>

  <p>
    <cxx-note>The library provides implicit conversions from <code>const charT*</code> and <code>std::basic_string&lt;charT, ...></code> to <code>std::basic_string_view&lt;charT, ...></code> so that user code can accept just <code>std::basic_string_view&lt;charT></code> as a non-templated parameter wherever a sequence of characters is expected.
    User-defined types should define their own implicit conversions to <code>std::basic_string_view</code> in order to interoperate with these functions.</cxx-note>
  </p>

  <p>
    The complexity of <code>basic_string_view</code> member functions is O(1) unless otherwise specified.
  </p>

  <cxx-section id="string.view.synop">
    <h1>Header <code>&lt;experimental/string_view></code> synopsis</h1>

    <pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v1 {
  <cxx-ref insynopsis="" to="string.view.template"></cxx-ref>
  template&lt;class charT, class traits = char_traits&lt;charT>>
      class basic_string_view;

  <cxx-ref insynopsis="" to="string.view.comparison"></cxx-ref>
  template&lt;class charT, class traits>
  constexpr bool operator==(basic_string_view&lt;charT, traits> x,
                            basic_string_view&lt;charT, traits> y) noexcept;
  template&lt;class charT, class traits>
  constexpr bool operator!=(basic_string_view&lt;charT, traits> x,
                            basic_string_view&lt;charT, traits> y) noexcept;
  template&lt;class charT, class traits>
  constexpr bool operator&lt; (basic_string_view&lt;charT, traits> x,
                               basic_string_view&lt;charT, traits> y) noexcept;
  template&lt;class charT, class traits>
  constexpr bool operator> (basic_string_view&lt;charT, traits> x,
                            basic_string_view&lt;charT, traits> y) noexcept;
  template&lt;class charT, class traits>
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits> x,
                               basic_string_view&lt;charT, traits> y) noexcept;
  template&lt;class charT, class traits>
  constexpr bool operator>=(basic_string_view&lt;charT, traits> x,
                            basic_string_view&lt;charT, traits> y) noexcept;
  // <i>see below</i>, sufficient additional overloads of comparison functions

  <cxx-ref insynopsis="" to="string.view.io"></cxx-ref>
  template&lt;class charT, class traits>
    basic_ostream&lt;charT, traits>&amp;
      operator&lt;&lt;(basic_ostream&lt;charT, traits>&amp; os,
                 basic_string_view&lt;charT, traits> str);

  // basic_string_view typedef names
  typedef basic_string_view&lt;char> string_view;
  typedef basic_string_view&lt;char16_t> u16string_view;
  typedef basic_string_view&lt;char32_t> u32string_view;
  typedef basic_string_view&lt;wchar_t> wstring_view;

}  // namespace fundamentals_v1
}  // namespace experimental

  <cxx-ref insynopsis="" to="string.view.hash"></cxx-ref>
  template &lt;class T> struct hash;
  template &lt;> struct hash&lt;experimental::string_view>;
  template &lt;> struct hash&lt;experimental::u16string_view>;
  template &lt;> struct hash&lt;experimental::u32string_view>;
  template &lt;> struct hash&lt;experimental::wstring_view>;
}  // namespace std</code></pre>

    <p>
      The function templates defined in <cxx-ref in="cxx" to="utility.swap"></cxx-ref> and <cxx-ref in="cxx" to="iterator.range"></cxx-ref> are available when <code>&lt;experimental/string_view></code> is included.
    </p>
  </cxx-section>

  <cxx-section id="string.view.template">
    <h1>Class template <code>basic_string_view</code></h1>

    <pre><code>namespace std {
namespace experimental {
namespace fundamentals_v1 {
  template&lt;class charT, class traits = char_traits&lt;charT>>
  class basic_string_view {
    public:
    // types
    typedef traits traits_type;
    typedef charT value_type;
    typedef charT* pointer;
    typedef const charT* const_pointer;
    typedef charT&amp; reference;
    typedef const charT&amp; const_reference;
    typedef <var>implementation-defined</var> const_iterator; // See <cxx-ref to="string.view.iterators"></cxx-ref>
    typedef const_iterator iterator;<cxx-footnote>Because <code>basic_string_view</code> refers to a constant sequence, <code>iterator</code> and <code>const_iterator</code> are the same type.</cxx-footnote>
    typedef reverse_iterator&lt;const_iterator> const_reverse_iterator;
    typedef const_reverse_iterator reverse_iterator;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    static constexpr size_type npos = size_type(-1);

    <cxx-ref insynopsis="" to="string.view.cons"></cxx-ref>
    constexpr basic_string_view() noexcept;
    constexpr basic_string_view(const basic_string_view&amp;) noexcept = default;
    basic_string_view&amp; operator=(const basic_string_view&amp;) noexcept = default;
    template&lt;class Allocator>
    basic_string_view(const basic_string&lt;charT, traits, Allocator>&amp; str) noexcept;
    constexpr basic_string_view(const charT* str);
    constexpr basic_string_view(const charT* str, size_type len);

    <cxx-ref insynopsis="" to="string.view.iterators"></cxx-ref>
    constexpr const_iterator begin() const noexcept;
    constexpr const_iterator end() const noexcept;
    constexpr const_iterator cbegin() const noexcept;
    constexpr const_iterator cend() const noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator crend() const noexcept;

    <cxx-ref insynopsis="" to="string.view.capacity"></cxx-ref>
    constexpr size_type size() const noexcept;
    constexpr size_type length() const noexcept;
    constexpr size_type max_size() const noexcept;
    constexpr bool empty() const noexcept;

    <cxx-ref insynopsis="" to="string.view.access"></cxx-ref>
    constexpr const_reference operator[](size_type pos) const;
    constexpr const_reference at(size_type pos) const;
    constexpr const_reference front() const;
    constexpr const_reference back() const;
    constexpr const_pointer data() const noexcept;

    <cxx-ref insynopsis="" to="string.view.modifiers"></cxx-ref>
    constexpr void clear() noexcept;
    constexpr void remove_prefix(size_type n);
    constexpr void remove_suffix(size_type n);
    constexpr void swap(basic_string_view&amp; s) noexcept;

    <cxx-ref insynopsis="" to="string.view.ops"></cxx-ref>
    template&lt;class Allocator>
    explicit operator basic_string&lt;charT, traits, Allocator>() const;
    template&lt;class Allocator = allocator&lt;charT> >
    basic_string&lt;charT, traits, Allocator> to_string(
      const Allocator&amp; a = Allocator()) const;

    size_type copy(charT* s, size_type n, size_type pos = 0) const;

    constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;
    constexpr int compare(basic_string_view s) const noexcept;
    constexpr int compare(size_type pos1, size_type n1, basic_string_view s) const;
    constexpr int compare(size_type pos1, size_type n1,
                          basic_string_view s, size_type pos2, size_type n2) const;
    constexpr int compare(const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1, const charT* s) const;
    constexpr int compare(size_type pos1, size_type n1,
                          const charT* s, size_type n2) const;
    constexpr size_type find(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find(const charT* s, size_type pos = 0) const;
    constexpr size_type rfind(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type rfind(charT c, size_type pos = npos) const noexcept;
    constexpr size_type rfind(const charT* s, size_type pos, size_type n) const;
    constexpr size_type rfind(const charT* s, size_type pos = npos) const;
    constexpr size_type find_first_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_of(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_of(const charT* s, size_type pos = npos) const;
    constexpr size_type find_first_not_of(basic_string_view s, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(charT c, size_type pos = 0) const noexcept;
    constexpr size_type find_first_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_first_not_of(const charT* s, size_type pos = 0) const;
    constexpr size_type find_last_not_of(basic_string_view s, size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(charT c, size_type pos = npos) const noexcept;
    constexpr size_type find_last_not_of(const charT* s, size_type pos, size_type n) const;
    constexpr size_type find_last_not_of(const charT* s, size_type pos = npos) const;

   private:
    const_pointer data_;  // <em>exposition only</em>
    size_type     size_;  // <em>exposition only</em>
  };
}  // namespace fundamentals_v1
}  // namespace experimental
}  // namespace std</code></pre>

    <p>
      In every specialization <code>basic_string_view&lt;charT, traits></code>, the type <code>traits</code> shall satisfy the character traits requirements (<cxx-ref in="cxx" to="char.traits"></cxx-ref>),
      and the type <code>traits::char_type</code> shall name the same type as <code>charT</code>.
    </p>
  </cxx-section>

  <cxx-section id="string.view.cons">
    <h1><code>basic_string_view</code> constructors and assignment operators</h1>

    <cxx-function>
      <cxx-signature>constexpr basic_string_view() noexcept;</cxx-signature>

      <cxx-effects>Constructs an empty <code>basic_string_view</code>.</cxx-effects>
      <cxx-postconditions><code>size_ == 0</code> and <code>data_ == nullptr</code>.</cxx-postconditions>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class Allocator> <wbr/>basic_string_view(const basic_string&lt;charT, traits, Allocator>&amp; str) noexcept;</cxx-signature>

      <cxx-effects>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.1"></cxx-ref>.</cxx-effects>
      <table is="cxx-table" id="tab:string.view.ctr.1">
        <caption><code>basic_string_view(const basic_string&amp;)</code> effects</caption>
        <tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str.data()</code></td></tr>
        <tr><td><code>size_</code></td><td><code>str.size()</code></td></tr>
      </table>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr basic_string_view(const charT* str);</cxx-signature>

      <cxx-requires><cxx-range begin="str" end="str + traits::length(str)"></cxx-range> is a valid range.</cxx-requires>
      <cxx-effects>Constructs a <code>basic_string_view</code> referring to the same string as <code>str</code>, with the postconditions
      in <cxx-ref to="tab:string.view.ctr.2"></cxx-ref>.</cxx-effects>

      <table is="cxx-table" id="tab:string.view.ctr.2"><caption>basic_string_view(const charT*) effects</caption>
      <tr><th>Element</th><th>Value</th></tr>
      <tr><td><code>data_</code></td><td><code>str</code></td></tr>
      <tr><td><code>size_</code></td><td><code>traits::length(str)</code></td></tr>
      </table>

      <cxx-complexity>O(<code>traits::length(str)</code>)</cxx-complexity>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr basic_string_view(const charT* str, size_type len);</cxx-signature>

      <cxx-requires><cxx-range begin="str" end="str + len"></cxx-range> is a valid range.</cxx-requires>
      <cxx-effects>Constructs a <code>basic_string_view</code>, with the postconditions in <cxx-ref to="tab:string.view.ctr.3"></cxx-ref>.</cxx-effects>
      <table is="cxx-table" id="tab:string.view.ctr.3"><caption><code>basic_string_view(const charT*, size_type)</code> effects</caption>
        <tr><th>Element</th><th>Value</th></tr>
        <tr><td><code>data_</code></td><td><code>str</code></td></tr>
        <tr><td><code>size_</code></td><td><code>len</code></td></tr>
      </table>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.iterators">
    <h1><code>basic_string_view</code> iterator support</h1>

    <cxx-function>
      <cxx-signature>typedef <var>implementation-defined</var> const_iterator;</cxx-signature>

      <p>
        A constant random-access iterator type such that, for a <code>const_iterator it</code>, if <code>&amp;*(it+N)</code> is valid, then it is equal to <code>(&amp;*it)+N</code>.
      </p>
      <p>
        For a <code>basic_string_view str</code>, any operation that invalidates a pointer in the range <cxx-range begin="str.data()" end="str.data()+str.size()"></cxx-range> invalidates pointers, iterators, and references returned from <code>str</code>'s methods.
      </p>
      <p>
        All requirements on container iterators (<cxx-ref in="cxx" to="container.requirements"></cxx-ref>) apply to <code>basic_string_view::const_iterator</code> as well.
      </p>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_iterator begin() const noexcept;</cxx-signature>
      <cxx-signature>constexpr const_iterator cbegin() const noexcept;</cxx-signature>
      <cxx-returns>An iterator such that <code>&amp;*begin() == data_</code> if <code>!empty()</code>,
      or else an unspecified value such that <cxx-range begin="begin()" end="end()"></cxx-range> is a valid range.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_iterator end() const noexcept;</cxx-signature>
      <cxx-signature>constexpr const_iterator cend() const noexcept;</cxx-signature>

      <cxx-returns> <code>begin() + size()</code></cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>const_reverse_iterator rbegin() const noexcept;</cxx-signature>
      <cxx-signature>const_reverse_iterator crbegin() const noexcept;</cxx-signature>
    
      <cxx-returns> <code>const_reverse_iterator(end())</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>const_reverse_iterator rend() const noexcept;</cxx-signature>
      <cxx-signature>const_reverse_iterator crend() const noexcept;</cxx-signature>
    
      <cxx-returns><code>const_reverse_iterator(begin())</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.capacity">
    <h1><code>basic_string_view</code> capacity</h1>

    <cxx-function>
      <cxx-signature>constexpr size_type size() const noexcept;</cxx-signature>
      <cxx-returns><code>size_</code></cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr size_type length() const noexcept;</cxx-signature>
      <cxx-returns><code>size_</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr size_type max_size() const noexcept;</cxx-signature>
      <cxx-returns>The largest possible number of char-like objects that can be referred to by a <code>basic_string_view</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr bool empty() const noexcept;</cxx-signature>
      <cxx-returns><code>size_ == 0</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.access">
    <h1><code>basic_string_view</code> element access</h1>

    <cxx-function>
      <cxx-signature>constexpr const_reference operator[](size_type pos) const;</cxx-signature>

      <cxx-requires><code>pos &lt; size()</code>.</cxx-requires>
      <cxx-returns><code>data_[pos]</code></cxx-returns>
      <cxx-throws>Nothing.</cxx-throws>
      <p><cxx-note>Unlike <code>basic_string::operator[]</code>,
        <code>basic_string_view::operator[](size())</code> has undefined behavior instead of returning <code>charT()</code>.</cxx-note></p>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_reference at(size_type pos) const;</cxx-signature>

      <cxx-throws><code>out_of_range</code> if <code>pos >= size()</code>.</cxx-throws>
      <cxx-returns><code>data_[pos]</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_reference front() const;</cxx-signature>

      <cxx-requires><code>!empty()</code></cxx-requires>
      <cxx-returns><code>data_[0]</code>.</cxx-returns>
      <cxx-throws>Nothing.</cxx-throws>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_reference back() const;</cxx-signature>

      <cxx-requires><code>!empty()</code></cxx-requires>
      <cxx-returns><code>data_[size() - 1]</code>.</cxx-returns>
      <cxx-throws>Nothing.</cxx-throws>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr const_pointer data() const noexcept;</cxx-signature>

      <cxx-returns><code>data_</code></cxx-returns>
      <p><cxx-note>Unlike <code>basic_string::data()</code> and string literals,
      <code>data()</code> may return a pointer to a buffer that is not null-terminated.
      Therefore it is typically a mistake to pass <code>data()</code> to a routine that takes just a <code>const charT*</code> and expects a null-terminated string.</cxx-note></p>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.modifiers">
    <h1><code>basic_string_view</code> modifiers</h1>

    <cxx-function>
      <cxx-signature>constexpr void clear() noexcept;</cxx-signature>
      <cxx-effects>Equivalent to <code>*this = basic_string_view()</code></cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr void remove_prefix(size_type n);</cxx-signature>

      <cxx-requires><code>n &lt;= size()</code></cxx-requires>
      <cxx-effects>Equivalent to <code>data_ += n; size_ -= n;</code></cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr void remove_suffix(size_type n);</cxx-signature>

      <cxx-requires><code>n &lt;= size()</code></cxx-requires>
      <cxx-effects>Equivalent to <code>size_ -= n;</code></cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr void swap(basic_string_view&amp; s) noexcept;</cxx-signature>

      <cxx-effects>Exchanges the values of <code>*this</code> and <code>s</code>.</cxx-effects>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.ops">
    <h1><code>basic_string_view</code> string operations</h1>

    <cxx-function>
      <cxx-signature>template&lt;class Allocator>
explicit<cxx-footnote>This conversion is explicit to avoid accidental O(N) operations on type mismatches.</cxx-footnote> operator basic_string&lt;
    charT, traits, Allocator>() const;</cxx-signature>

      <cxx-effects>Equivalent to <code>basic_string&lt;charT, traits, Allocator>(begin(), end()).</code></cxx-effects>
      <cxx-complexity>O(<code>size()</code>)</cxx-complexity>
      <p><cxx-note>Users who want to control the allocator instance should call <code>to_string(allocator)</code>.</cxx-note></p>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class Allocator = allocator&lt;charT>>
basic_string&lt;charT, traits, Allocator> to_string(
    const Allocator&amp; a = Allocator()) const;</cxx-signature>

      <cxx-returns><code>basic_string&lt;charT, traits, Allocator>(begin(), end(), a)</code>.</cxx-returns>
      <cxx-complexity>O(<code>size()</code>)</cxx-complexity>
    </cxx-function>

    <cxx-function>
      <cxx-signature>size_type copy(charT* s, size_type n, size_type pos = 0) const;</cxx-signature>

      <p>Let <code>rlen</code> be the smaller of <code>n</code> and <code>size() - pos</code>.</p>
      <cxx-throws><code>out_of_range</code> if <code>pos > size()</code>.</cxx-throws>
      <cxx-requires><cxx-range begin="s" end="s + rlen"></cxx-range> is a valid range.</cxx-requires>
      <cxx-effects>Equivalent to <code>std::copy_n(begin() + pos, rlen, s).</code></cxx-effects>
      <cxx-returns><code>rlen</code>.</cxx-returns>
      <cxx-complexity>O(<code>rlen</code>)</cxx-complexity>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr basic_string_view substr(size_type pos = 0, size_type n = npos) const;</cxx-signature>

      <cxx-throws><code>out_of_range</code> if <code>pos > size()</code>.</cxx-throws>
      <cxx-effects>Determines the effective length <code><var>rlen</var></code> of the string to reference as the smaller of <code>n</code> and <code>size() - pos</code>.</cxx-effects>
      <cxx-returns><code>basic_string_view(data()+pos, <var>rlen</var>)</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr int compare(basic_string_view str) const noexcept;</cxx-signature>

      <cxx-effects>Determines the effective length <code><var>rlen</var></code> of the strings to compare as the smaller of <code>size()</code> and <code>str.size()</code>.
        The function then compares the two strings by calling <code>traits::compare(data(), str.data(), <var>rlen</var>)</code>.</cxx-effects>
      <cxx-complexity>O(<code><var>rlen</var></code>)</cxx-complexity>
      <cxx-returns>The nonzero result if the result of the comparison is nonzero.
        Otherwise, returns a value as indicated in <cxx-ref to="tab:string.view.compare"></cxx-ref>.</cxx-returns>
      <table is="cxx-table" id="tab:string.view.compare" class="center">
        <caption><code>compare()</code> results</caption>
        <tr><th>Condition</th><th>Return Value</th></tr>
        <tr><td><code>size() &lt; str.size()</code></td><td><code>&lt; 0</code></td></tr>
        <tr><td><code>size() == str.size()</code></td><td><code>&#xA0; 0</code></td></tr>
        <tr><td><code>size() >  str.size()</code></td><td><code>> 0</code></td></tr>
      </table>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str) const;</cxx-signature>
      <cxx-effects>Equivalent to <code>substr(pos1, n1).compare(str)</code>.</cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr int compare(size_type pos1, size_type n1, basic_string_view str,
                      size_type pos2, size_type n2) const;</cxx-signature>
      <cxx-effects>Equivalent to <code>substr(pos1, n1).compare(str.substr(pos2, n2))</code>.</cxx-effects>
    </cxx-function>

    <cxx-function>
      <cxx-signature>constexpr int compare(const charT* s) const;</cxx-signature>
      <cxx-effects>Equivalent to <code>compare(basic_string_view(s))</code>.</cxx-effects>
    </cxx-function>
    
    <cxx-function>
      <cxx-signature>constexpr int compare(size_type pos1, size_type n1, const charT* s) const;</cxx-signature>
      <cxx-effects>Equivalent to <code>substr(pos1, n1).compare(basic_string_view(s))</code>.</cxx-effects>
    </cxx-function>
    
    <cxx-function>
      <cxx-signature>constexpr int compare(size_type pos1, size_type n1,
                      const charT* s, size_type n2) const;</cxx-signature>
      <cxx-effects>Equivalent to <code>substr(pos1, n1).compare(basic_string_view(s, n2))</code>.</cxx-effects>
    </cxx-function>

    <cxx-section id="string.view.find">
      <h1>Searching <code>basic_string_view</code></h1>

      <p>This section specifies the <code>basic_string_view</code> member functions named
        <code>find</code>, <code>rfind</code>, <code>find_first_of</code>, <code>find_last_of</code>, <code>find_first_not_of</code>, and <code>find_last_not_of</code>.</p>

      <p>Member functions in this section have complexity O(<code>size() * str.size()</code>) at worst,
        although implementations are encouraged to do better.</p>

      <p>Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code><var>fx1</var>(basic_string_view(s), pos)</code>.</p>

      <p>Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx1</var>(const charT* s, size_type pos, size_type n);</code></pre>
      <p class="cont">is equivalent to <code><var>fx1</var>(basic_string_view(s, n), pos)</code>.</p>

      <p>Each member function of the form</p>
      <pre><code>constexpr <var>return-type fx2</var>(charT c, size_type pos);</code></pre>
      <p class="cont">is equivalent to <code><var>fx2</var>(basic_string_view(&amp;c, 1), pos)</code>.</p>

      <cxx-function>
        <cxx-signature>constexpr size_type find(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature>

        <cxx-effects>
          Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr size_type rfind(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature>

        <cxx-effects>
          Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos + str.size() &lt;= size()</code></li>
            <li><code>traits::eq(at(xpos+I), str.at(I))</code> for all elements <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr size_type find_first_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature>

        <cxx-effects>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr size_type find_last_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature>

        <cxx-effects>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for some element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr size_type find_first_not_of(basic_string_view str, size_type pos = 0) const noexcept;</cxx-signature>

        <cxx-effects>Determines the lowest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>pos &lt;= xpos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>. Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>

      <cxx-function>
        <cxx-signature>constexpr size_type find_last_not_of(basic_string_view str, size_type pos = npos) const noexcept;</cxx-signature>

        <cxx-effects>Determines the highest position <code>xpos</code>, if possible, such that the following conditions obtain:
          <ul>
            <li><code>xpos &lt;= pos</code></li>
            <li><code>xpos &lt; size()</code></li>
            <li><code>traits::eq(at(xpos), str.at(I))</code> for no element <code>I</code> of the string referenced by <code>str</code>.</li>
          </ul>
        </cxx-effects>
        <cxx-returns><code>xpos</code> if the function can determine such a value for <code>xpos</code>.
          Otherwise, returns <code>npos</code>.</cxx-returns>
        <cxx-remarks>Uses <code>traits::eq()</code>.</cxx-remarks>
      </cxx-function>
    </cxx-section>
  </cxx-section>

  <cxx-section id="string.view.comparison">
    <h1><code>basic_string_view</code> non-member comparison functions</h1>

    <p>
      Let <code>S</code> be <code>basic_string_view&lt;charT, traits></code>, and <code>sv</code> be an instance of <code>S</code>.
      Implementations shall provide sufficient additional overloads marked <code>constexpr</code> and <code>noexcept</code>
      so that an object <code><var>t</var></code> with an implicit conversion to <code>S</code> can be compared according to <cxx-ref to="tab:string.view.comparison.overloads"></cxx-ref>.
    </p>

    <table is="cxx-table" id="tab:string.view.comparison.overloads" class="center"><caption>Additional <code>basic_string_view</code> comparison overloads</caption>
      <tr><th>Expression</th><th>Equivalent to</th></tr>
      <tr><td><code>t == sv</code></td><td><code>S(t) == sv</code></td></tr>
      <tr><td><code>sv == t</code></td><td><code>sv == S(t)</code></td></tr>
      <tr><td><code>t != sv</code></td><td><code>S(t) != sv</code></td></tr>
      <tr><td><code>sv != t</code></td><td><code>sv != S(t)</code></td></tr>
      <tr><td><code>t &lt; sv</code></td><td><code>S(t) &lt; sv</code></td></tr>
      <tr><td><code>sv &lt; t</code></td><td><code>sv &lt; S(t)</code></td></tr>
      <tr><td><code>t > sv</code></td><td><code>S(t) > sv</code></td></tr>
      <tr><td><code>sv > t</code></td><td><code>sv > S(t)</code></td></tr>
      <tr><td><code>t &lt;= sv</code></td><td><code>S(t) &lt;= sv</code></td></tr>
      <tr><td><code>sv &lt;= t</code></td><td><code>sv &lt;= S(t)</code></td></tr>
      <tr><td><code>t >= sv</code></td><td><code>S(t) >= sv</code></td></tr>
      <tr><td><code>sv >= t</code></td><td><code>sv >= S(t)</code></td></tr>
    </table>

    <cxx-example>A sample conforming implementation for operator== would be:
<pre><code>template&lt;class T> using __identity = typename std::decay&lt;T>::type;
template&lt;class charT, class traits>
constexpr bool operator==(
    basic_string_view&lt;charT, traits> lhs,
    basic_string_view&lt;charT, traits> rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits>
constexpr bool operator==(
    basic_string_view&lt;charT, traits> lhs,
    __identity&lt;basic_string_view&lt;charT, traits>> rhs) noexcept {
  return lhs.compare(rhs) == 0;
}
template&lt;class charT, class traits>
constexpr bool operator==(
    __identity&lt;basic_string_view&lt;charT, traits>> lhs,
    basic_string_view&lt;charT, traits> rhs) noexcept {
  return lhs.compare(rhs) == 0;
}</code></pre>
    </cxx-example>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator==(basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) == 0</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator!=(basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) != 0</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator&lt; (basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) &lt; 0</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator> (basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) > 0</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) &lt;= 0</code>.</cxx-returns>
    </cxx-function>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  constexpr bool operator>=(basic_string_view&lt;charT, traits> lhs,
                            basic_string_view&lt;charT, traits> rhs) noexcept;</cxx-signature>
      <cxx-returns> <code>lhs.compare(rhs) >= 0</code>.</cxx-returns>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.io">
    <h1>Inserters and extractors</h1>

    <cxx-function>
      <cxx-signature>template&lt;class charT, class traits>
  basic_ostream&lt;charT, traits>&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits>&amp; os,
               basic_string_view&lt;charT, traits> str);</cxx-signature>

      <cxx-effects>Equivalent to <code>os &lt;&lt; str.to_string()</code>.</cxx-effects>
    </cxx-function>
  </cxx-section>

  <cxx-section id="string.view.hash">
    <h1>Hash support</h1>

    <cxx-function>
      <cxx-signature>template &lt;> struct hash&lt;experimental::string_view>;</cxx-signature>
      <cxx-signature>template &lt;> struct hash&lt;experimental::u16string_view>;</cxx-signature>
      <cxx-signature>template &lt;> struct hash&lt;experimental::u32string_view>;</cxx-signature>
      <cxx-signature>template &lt;> struct hash&lt;experimental::wstring_view>;</cxx-signature>
      <p>The template specializations shall meet the requirements of class template hash (<cxx-ref in="cxx" to="unord.hash"></cxx-ref>).</p>
    </cxx-function>
  </cxx-section>
</cxx-clause>

<cxx-include href="memory.html"></cxx-include>
<cxx-include href="algorithms.html"></cxx-include>
<cxx-include href="net.html"></cxx-include>

<cxx-publish-button source="https://github.com/cplusplus/fundamentals-ts"></cxx-publish-button>
</body>
</html>
