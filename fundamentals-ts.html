<!DOCTYPE html>
<!-- Sources at https://github.com/cplusplus/fundamentals-ts -->
<html lang="en"><head><!--[if lte IE 8]><script>document.createElement("nav");document.createElement("section");document.createElement("time");document.createElement("CXX-TITLEPAGE");document.createElement("CXX-DOCNUM");document.createElement("CXX-REVISES");document.createElement("CXX-EDITOR");document.createElement("CXX-EMAIL");document.createElement("CXX-TOC");document.createElement("CXX-CLAUSE");document.createElement("CXX-SECTION");document.createElement("CXX-REF");document.createElement("CXX-FOREIGN-INDEX");document.createElement("CXX-EXAMPLE");document.createElement("CXX-NOTE");document.createElement("CXX-FUNCTION");document.createElement("CXX-SIGNATURE");document.createElement("CXX-REMARKS");document.createElement("CXX-EFFECTS");document.createElement("CXX-RETURNS");document.createElement("CXX-REQUIRES");document.createElement("CXX-THROWS");document.createElement("CXX-POSTCONDITIONS");document.createElement("CXX-GRAMMARTERM");document.createElement("CXX-PUBLISH-BUTTON");</script><![endif]--><style>template {display: none !important;} /* injected by platform.js */</style><style>body {transition: opacity ease-in 0.2s; } 
body[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } 
</style><style shim-shadowdom-css="">style { display: none !important; }
cxx-function {
	display: block; page-break-inside: avoid;
}

cxx-function:not(:last-child) {
	margin-bottom: 3ex;
}

cxx-function > dl {
	margin: 0px 0px 0px 2em;
}

cxx-function > pre {
	margin: 0px;
}cxx-signature {
	padding-left: 2em; display: block; text-indent: -2em;
}

cxx-signature.formatted {
	text-indent: 0px;
}cxx-attribute {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-attribute dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-attribute dd {
	margin-left: 0em;
}

cxx-attribute dd > ul, cxx-attribute dd > ol {
	clear: left;
}cxx-requires {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-requires dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-requires dd {
	margin-left: 0em;
}

cxx-requires dd > ul, cxx-requires dd > ol {
	clear: left;
}cxx-preconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-preconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-preconditions dd {
	margin-left: 0em;
}

cxx-preconditions dd > ul, cxx-preconditions dd > ol {
	clear: left;
}cxx-effects {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-effects dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-effects dd {
	margin-left: 0em;
}

cxx-effects dd > ul, cxx-effects dd > ol {
	clear: left;
}cxx-synchronization {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-synchronization dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-synchronization dd {
	margin-left: 0em;
}

cxx-synchronization dd > ul, cxx-synchronization dd > ol {
	clear: left;
}cxx-postconditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-postconditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-postconditions dd {
	margin-left: 0em;
}

cxx-postconditions dd > ul, cxx-postconditions dd > ol {
	clear: left;
}cxx-returns {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-returns dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-returns dd {
	margin-left: 0em;
}

cxx-returns dd > ul, cxx-returns dd > ol {
	clear: left;
}cxx-throws {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-throws dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-throws dd {
	margin-left: 0em;
}

cxx-throws dd > ul, cxx-throws dd > ol {
	clear: left;
}cxx-complexity {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-complexity dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-complexity dd {
	margin-left: 0em;
}

cxx-complexity dd > ul, cxx-complexity dd > ol {
	clear: left;
}cxx-exception-safety {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-exception-safety dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-exception-safety dd {
	margin-left: 0em;
}

cxx-exception-safety dd > ul, cxx-exception-safety dd > ol {
	clear: left;
}cxx-remarks {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-remarks dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-remarks dd {
	margin-left: 0em;
}

cxx-remarks dd > ul, cxx-remarks dd > ol {
	clear: left;
}cxx-error-conditions {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-error-conditions dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-error-conditions dd {
	margin-left: 0em;
}

cxx-error-conditions dd > ul, cxx-error-conditions dd > ol {
	clear: left;
}cxx-notes {
	display: block; margin-top: 0.5em; margin-bottom: 0.5em;
}

cxx-notes dt {
	float: left; font-style: italic; font-weight: normal; padding-right: 1ex;
}

cxx-notes dd {
	margin-left: 0em;
}

cxx-notes dd > ul, cxx-notes dd > ol {
	clear: left;
}cxx-section {
	display: block;
}

cxx-section:target {
	background-color: inherit;
}

cxx-section:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-section header > h1 {
	display: inline; font-size: 100%;
}

cxx-section header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-section header::after {
	clear: both; display: block; content: " "; height: 0px;
}cxx-clause {
	display: block;
}

cxx-clause:target {
	background-color: inherit;
}

cxx-clause:target > section > h1 {
	background-color: rgb(255, 238, 221);
}

cxx-clause header > h1 {
	display: inline; font-size: 100%;
}

cxx-clause header {
	font-weight: bold; margin-top: 20px; margin-bottom: 20px; page-break-inside: avoid; page-break-after: avoid;
}

cxx-clause header::after {
	clear: both; display: block; content: " "; height: 0px;
}[is=cxx-table] {
	margin-left: auto; margin-right: auto; border-collapse: collapse; border: thin solid black;
}

[is=cxx-table] caption {
	white-space: nowrap;
}

[is=cxx-table] caption caption {
	display: inline;
}

[is=cxx-table] th, [is=cxx-table] td {
	border-style: solid none; border-color: black; border-width: thin; padding: 0px 0.25em;
}

[is=cxx-table].column-rules th, [is=cxx-table].column-rules td {
	border-left-style: solid; border-right-style: solid;
}

[is=cxx-table] th {
	border-bottom: medium double;
}

[is=cxx-table].single-border th {
	border-bottom: thin solid;
}

[is=cxx-table].center td {
	text-align: center;
}

[is=cxx-table].list td {
	border: medium none; vertical-align: top;
}

[is=cxx-table].list ul {
	padding-left: 0px; margin: 0px;
}

[is=cxx-table].list ul li::before {
	content: "";
}cxx-figure {
	margin-left: auto; margin-right: auto;
}

cxx-figure figcaption {
	white-space: nowrap; text-align: center;
}

cxx-figure figcaption figcaption {
	display: inline;
}[is=cxx-definition-section] dt {
	font-weight: bold;
}

[is=cxx-definition-section] dd {
	margin-left: 0px;
}cxx-toc {
	display: block;
}

cxx-toc nav > ol {
	font-weight: bold;
}

cxx-toc ol {
	font-weight: normal; padding-left: 0px; margin-left: 0px;
}

cxx-toc li {
	list-style-type: none;
}

cxx-toc .marker {
	display: inline-block;
}

cxx-toc li .marker {
	width: 2em; text-align: left;
}

cxx-toc ol ol {
	margin-left: 2em;
}

cxx-toc li li .marker {
	width: 3em;
}

cxx-toc ol ol ol {
	margin-left: 3em;
}

cxx-toc li li li .marker {
	width: 3.5em;
}

cxx-toc ol ol ol ol {
	margin-left: 3.5em;
}

cxx-toc li li li li .marker {
	width: 4.5em;
}cxx-get-element-by-id {
	display: none;
}cxx-foreign-index {
	display: none;
}cxx-titlepage, cxx-titlepage .page {
	display: block; min-height: 100%;
}

cxx-titlepage .page {
	page-break-before: always; page-break-after: always; min-height: 100vh; margin-bottom: 2em;
}

@media print {
cxx-titlepage .page {
	height: 8.8in;
}


}

cxx-titlepage .page {
	position: relative;
}

cxx-titlepage table td, cxx-titlepage table th {
	border: medium none;
}

cxx-titlepagebody.cxx-draft .header, body.cxx-draft cxx-titlepage .header {
	position: absolute; right: 0px; top: 0px;
}

cxx-titlepagebody.cxx-draft h1, body.cxx-draft cxx-titlepage h1 {
	position: absolute; top: 40%; text-align: center;
}

cxx-titlepagebody.cxx-draft p.warning, body.cxx-draft cxx-titlepage p.warning {
	position: absolute; bottom: 5%;
}

cxx-titlepagebody.cxx-pdts .header, body.cxx-pdts cxx-titlepage .header, cxx-titlepagebody.cxx-dts .header, body.cxx-dts cxx-titlepage .header {
	position: absolute; right: 0px; top: 0px; text-align: right;
}

cxx-titlepagebody.cxx-pdts .header cxx-docnum, body.cxx-pdts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-dts .header cxx-docnum, body.cxx-dts cxx-titlepage .header cxx-docnum {
	font-size: 150%;
}

cxx-titlepagebody.cxx-pdts .header cxx-docnum, body.cxx-pdts cxx-titlepage .header cxx-docnum, cxx-titlepagebody.cxx-dts .header cxx-docnum, body.cxx-dts cxx-titlepage .header cxx-docnum {
	font-size: 150%;
}

cxx-titlepagebody.cxx-pdts hgroup, body.cxx-pdts cxx-titlepage hgroup, cxx-titlepagebody.cxx-dts hgroup, body.cxx-dts cxx-titlepage hgroup {
	position: absolute; top: 30%;
}

cxx-titlepagebody.cxx-pdts hgroup *, body.cxx-pdts cxx-titlepage hgroup *, cxx-titlepagebody.cxx-dts hgroup *, body.cxx-dts cxx-titlepage hgroup * {
	margin: 0px;
}

cxx-titlepagebody.cxx-pdts hgroup h1, body.cxx-pdts cxx-titlepage hgroup h1, cxx-titlepagebody.cxx-dts hgroup h1, body.cxx-dts cxx-titlepage hgroup h1 {
	font-size: 150%; font-weight: bold;
}

cxx-titlepagebody.cxx-pdts hgroup h2, body.cxx-pdts cxx-titlepage hgroup h2, cxx-titlepagebody.cxx-dts hgroup h2, body.cxx-dts cxx-titlepage hgroup h2 {
	font-size: 100%; font-weight: normal;
}

cxx-titlepagebody.cxx-pdts .footer, body.cxx-pdts cxx-titlepage .footer, cxx-titlepagebody.cxx-dts .footer, body.cxx-dts cxx-titlepage .footer {
	position: absolute; left: 0px; bottom: 5%;
}

cxx-titlepagebody.cxx-pdts figure, body.cxx-pdts cxx-titlepage figure, cxx-titlepagebody.cxx-dts figure, body.cxx-dts cxx-titlepage figure {
	border: 1px solid rgb(17, 17, 17); padding: 10px; margin-left: auto; margin-right: auto;
}

cxx-titlepagebody.cxx-pdts figcaption, body.cxx-pdts cxx-titlepage figcaption, cxx-titlepagebody.cxx-dts figcaption, body.cxx-dts cxx-titlepage figcaption {
	text-align: center; font-weight: bold;
}

cxx-titlepagebody.cxx-pdts .warning, body.cxx-pdts cxx-titlepage .warning, cxx-titlepagebody.cxx-dts .warning, body.cxx-dts cxx-titlepage .warning {
	position: absolute; bottom: 20%;
}

cxx-titlepagebody.cxx-pdts .copyright address, body.cxx-pdts cxx-titlepage .copyright address, cxx-titlepagebody.cxx-dts .copyright address, body.cxx-dts cxx-titlepage .copyright address {
	font-style: normal; margin-left: 2em;
}

cxx-titlepagebody.cxx-pdts .copyright address a, body.cxx-pdts cxx-titlepage .copyright address a, cxx-titlepagebody.cxx-dts .copyright address a, body.cxx-dts cxx-titlepage .copyright address a {
	color: inherit; text-decoration: inherit;
}

cxx-titlepage th {
	text-align: left; vertical-align: top;
}cxx-ednote {
	display: block;
}

cxx-ednotebody.cxx-pdts, body.cxx-pdts cxx-ednote {
	display: none;
}

cxx-ednote aside {
	float: right; max-width: 40%; margin: 1ex; border: 1px dashed rgb(136, 136, 136); padding: 1ex; background-color: rgb(238, 238, 238);
}

cxx-ednote.para aside {
	float: none; max-width: none;
}cxx-note .nowrap {
	white-space: nowrap;
}cxx-footnote {
	font-family: serif; white-space: normal; text-indent: initial;textIndent: initial; text-indent: initial; 
}

@media screen {
cxx-footnote aside {
	float: right; max-width: 30%; margin-left: 1em;
}


}

@media print {
cxx-footnote sup, cxx-footnote .marker {
	display: none;
}

cxx-footnote aside {
	
}


}cxx-example {
	display: block;
}

cxx-example.inline {
	display: inline;
}

cxx-example .nowrap {
	white-space: nowrap;
}cxx-publish-button {
	display: block;
}cxx-codeblock {
	display: block;
}bnf-grammar {
	display: block; font-style: italic; margin-left: 0.35in;
}bnf-rule {
	display: block; margin-left: 0.6in;
}bnf-alt {
	display: block; margin-left: 1.2in;
}bnf-terminal {
	font-style: normal;
}w-br {
	white-space: normal;
}

w-br::after {
	content: "​";
}</style>
  <meta charset="utf-8">
  
  <style shim-shadowdom-css="">/* Copyright 2014 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

@page {
    margin: 10%;
    @top-left { content: "© ISO/IEC"; font-size: 10pt; }
    @top-right { content: string(docnum); font-weight: bold; font-size: 10pt; }
    @bottom-left { content: string(current-section, last); font-size: 10pt; }
    @bottom-right { content: counter(page); font-size: 10pt; }
}
@page :first {
    /* @top-left is defined by base.js. */
    @top-right { content: normal; }
    @bottom-left { content: normal; }
    @bottom-right { content: normal; }
}

body { margin: 0; }

@media screen {
    body { max-width: 7in;
           /* Make room for paragraph numbers. */
           margin-left: 2em }
}

@media print {
    html { font-size: 10pt; }
    *   code { font-size: 80%; }
    /* Note that only Prince generates clickable links. */
    *   a[href] { text-decoration:none; }
}

@media screen {
    /* Needed to make the <cxx-titlepage>'s vertical spacing work.
       For print see the <cxx-titlepage> definition. */
    html, body {height: 100%}
}

cxx-docnum { string-set: docnum content(); }

cxx-clause { page-break-before: always; }
@media screen {
    cxx-clause, cxx-toc { margin-top: 3em; }
}

cxx-clause  header { font-size: 150%; }
cxx-toc  h1 { font-size: 150%; }
cxx-clause cxx-section  header { font-size: 117%; }
cxx-clause cxx-section cxx-section  header { font-size: 100%; }

[data-bookmark-label] { bookmark-label: attr(data-bookmark-label); }
h1 { bookmark-level: 1; }
cxx-toc  h1 { bookmark-level: 2; }
cxx-clause h1 { bookmark-level: 2; }
cxx-clause cxx-section h1 { bookmark-level: 3; }
cxx-clause cxx-section cxx-section h1 { bookmark-level: 4; }
/* The <h2> is a subtitle, which shouldn't get a PDF bookmark. */
cxx-titlepage  h2 { bookmark-level: none; }

*  .section-number { string-set: current-section "§ " content(); }

p {margin-top: .5em; margin-bottom: .5em}
p:first-child, ul, ol {margin-top: 0}

[para_num]::before { content: attr(para_num); float: left;
                     font-size: 70%; margin-left: -2.5em; width: 1.5em; text-align: right; }

del {text-decoration: line-through; color: #8B0040;}
ins {text-decoration: underline; color: #005100;}

pre {
    margin-left: 1em;
    margin-top: .5em;
    margin-bottom: .5em;
}

*   wbr::after {
    white-space: normal;
    content: '\200B';
}
*   code {
    /* Make inline code avoid line wraps unless we override it with <wbr>. */
    white-space: nowrap;
}
*   pre code {
    /* Keep block-code wrapping according to its context. */
    white-space: inherit;
}

*   table {
    border-collapse: collapse;
}
*   td, th {
    padding-left: .2em;
    padding-right: .2em;
    border: thin solid black;
}

/* Use an em-dash for the list bullet.
   'print' is a proxy for supporting ::marker. */
@media screen {
    ul {
        list-style: none;
        /* Relative positioning on the 'ul' lets the absolutely-positioned
           marker align relative to it.*/
        position: relative;
    }
    ul li:before {
        content: "\2014";
        position: absolute; left: 10px;
    }
}
@media print {
    ul li::marker {
        content: "\2014";
    }
    [is=cxx-table].list ul li::marker {
        content: none;
    }
}

/* This is here rather than inside elements/toc.html because browsers
   don't understand leader() or target-counter(), so they drop them
   inside the CSSOM. */
@media print {
    /* Generate page numbers in the table of contents. */
    cxx-toc  a[href]::after { content: leader(" . ") target-counter(attr(href), page); }

    cxx-footnote  aside { float: footnote; footnote-policy: line; }
}</style><style shim-shadowdom-css="">/*******************************
          Flex Layout
*******************************/

html   [layout][horizontal], html   [layout][vertical] {
  display: -ms-flexbox;
  display: -webkit-flex;
  display: flex;
}

html   [layout][horizontal][inline], html   [layout][vertical][inline] {
  display: -ms-inline-flexbox;
  display: -webkit-inline-flex;
  display: inline-flex;
}

html   [layout][horizontal] {
  -ms-flex-direction: row;
  -webkit-flex-direction: row;
  flex-direction: row;
}

html   [layout][horizontal][reverse] {
  -ms-flex-direction: row-reverse;
  -webkit-flex-direction: row-reverse;
  flex-direction: row-reverse;
}

html   [layout][vertical] {
  -ms-flex-direction: column;
  -webkit-flex-direction: column;
  flex-direction: column;
}

html   [layout][vertical][reverse] {
  -ms-flex-direction: column-reverse;
  -webkit-flex-direction: column-reverse;
  flex-direction: column-reverse;
}

html   [layout][wrap] {
  -ms-flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  flex-wrap: wrap;
}

html   [layout][wrap-reverse] {
  -ms-flex-wrap: wrap-reverse;
  -webkit-flex-wrap: wrap-reverse;
  flex-wrap: wrap-reverse;
}

html   [flex] {
  -ms-flex: 1 1 0.000000001px;
  -webkit-flex: 1;
  flex: 1;
  -webkit-flex-basis: 0.000000001px;
  flex-basis: 0.000000001px;
}

html   [vertical][layout] > [flex][auto-vertical], html   [vertical][layout]  [flex][auto-vertical] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html   [flex][auto] {
  -ms-flex: 1 1 auto;
  -webkit-flex-basis: auto;
  flex-basis: auto;
}

html   [flex][none] {
  -ms-flex: none;
  -webkit-flex: none;
  flex: none;
}

html   [flex][one] {
  -ms-flex: 1;
  -webkit-flex: 1;
  flex: 1;
}

html   [flex][two] {
  -ms-flex: 2;
  -webkit-flex: 2;
  flex: 2;
}

html   [flex][three] {
  -ms-flex: 3;
  -webkit-flex: 3;
  flex: 3;
}

html   [flex][four] {
  -ms-flex: 4;
  -webkit-flex: 4;
  flex: 4;
}

html   [flex][five] {
  -ms-flex: 5;
  -webkit-flex: 5;
  flex: 5;
}

html   [flex][six] {
  -ms-flex: 6;
  -webkit-flex: 6;
  flex: 6;
}

html   [flex][seven] {
  -ms-flex: 7;
  -webkit-flex: 7;
  flex: 7;
}

html   [flex][eight] {
  -ms-flex: 8;
  -webkit-flex: 8;
  flex: 8;
}

html   [flex][nine] {
  -ms-flex: 9;
  -webkit-flex: 9;
  flex: 9;
}

html   [flex][ten] {
  -ms-flex: 10;
  -webkit-flex: 10;
  flex: 10;
}

html   [flex][eleven] {
  -ms-flex: 11;
  -webkit-flex: 11;
  flex: 11;
}

html   [flex][twelve] {
  -ms-flex: 12;
  -webkit-flex: 12;
  flex: 12;
}

/* alignment in cross axis */

html   [layout][start] {
  -ms-flex-align: start;
  -webkit-align-items: flex-start;
  align-items: flex-start;
}

html   [layout][center], html   [layout][center-center] {
  -ms-flex-align: center;
  -webkit-align-items: center;
  align-items: center;
}

html   [layout][end] {
  -ms-flex-align: end;
  -webkit-align-items: flex-end;
  align-items: flex-end;
}

/* alignment in main axis */

html   [layout][start-justified] {
  -ms-flex-pack: start;
  -webkit-justify-content: flex-start;
  justify-content: flex-start;
}

html   [layout][center-justified], html   [layout][center-center] {
  -ms-flex-pack: center;
  -webkit-justify-content: center;
  justify-content: center;
}

html   [layout][end-justified] {
  -ms-flex-pack: end;
  -webkit-justify-content: flex-end;
  justify-content: flex-end;
}

html   [layout][around-justified] {
  -ms-flex-pack: distribute;
  -webkit-justify-content: space-around;
  justify-content: space-around;
}

html   [layout][justified] {
  -ms-flex-pack: justify;
  -webkit-justify-content: space-between;
  justify-content: space-between;
}

/* self alignment */

html   [self-start] {
  -ms-align-self: flex-start;
  -webkit-align-self: flex-start;
  align-self: flex-start;
}

html   [self-center] {
  -ms-align-self: center;
  -webkit-align-self: center;
  align-self: center;
}

html   [self-end] {
  -ms-align-self: flex-end;
  -webkit-align-self: flex-end;
  align-self: flex-end;
}

html   [self-stretch] {
  -ms-align-self: stretch;
  -webkit-align-self: stretch;
  align-self: stretch;
}

/*******************************
          Other Layout
*******************************/

html   [block] {
  display: block;
}

/* ie support for hidden */
html   [hidden] {
  display: none !important;
}

html   [relative] {
  position: relative;
}

html   [fit] {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}

body[fullbleed] {
  margin: 0;
  height: 100vh;
}

/*******************************
            Other
*******************************/

html   [segment], html   segment {
  display: block;
  position: relative;
  -webkit-box-sizing: border-box;
  -ms-box-sizing: border-box;
  box-sizing: border-box;
  margin: 1em 0.5em;
  padding: 1em;
  background-color: white;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1);
  border-radius: 5px 5px 5px 5px;
}</style>
<style>@page :first { @top-left { content: "© ISO 2015 — All rights reserved"; } }</style><title>C++ Extensions for Library Fundamentals, Version 2, Working Draft</title></head>
<body class="cxx-draft">
<cxx-titlepage>
    
    
      <div class="page">
        <table class="header">
          
            <tr><th>Document Number:</th><td><cxx-docnum>D????</cxx-docnum></td></tr>
          
          
            <tr><th>Date:</th><td><time pubdate="">2015-??-??</time></td></tr>
          
          
            <tr><th>Revises:</th><td><cxx-revises><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4336">N4336</a></cxx-revises></td></tr>
          
          
            <tr><th>Editor:</th><td><cxx-editor>
    Jeffrey Yasskin<br>
    Google, Inc.<br>
    <cxx-email><a href="mailto:jyasskin@google.com">jyasskin@google.com</a></cxx-email>
  </cxx-editor></td></tr>
          
        </table>
        <h1>Working Draft, C++ Extensions for Library Fundamentals, Version 2</h1>
        <p class="warning"><strong>Note: this is an early draft. It’s known to be
        incomplet and incorrekt, and it has lots of b<span style="margin-left: -1.2pt; margin-right: 1pt">a</span>d<span style="width:1.5em"> </span>for<span style="margin-left:-3pt; margin-right:0.6pt">mat</span>ti<span style="position:relative; top:-0.15ex">n</span>g.</strong></p>
      </div>
    

    

    
  </cxx-titlepage>

<cxx-toc>
    
    <nav>
      <h1>Contents</h1>
      
        
          <ol>
            
              <li><span class="marker">1</span><a href="#general">General</a>
        
          <ol>
            
              <li><span class="marker">1.1</span><a href="#general.scope">Scope</a>
        
      </li>
            
              <li><span class="marker">1.2</span><a href="#general.references">Normative references</a>
        
      </li>
            
              <li><span class="marker">1.3</span><a href="#general.namespaces">Namespaces, headers, and modifications to standard classes</a>
        
      </li>
            
              <li><span class="marker">1.4</span><a href="#general.plans">Future plans (Informative)</a>
        
      </li>
            
              <li><span class="marker">1.5</span><a href="#general.feature.test">Feature-testing recommendations (Informative)</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2</span><a href="#utilities">General utilities library</a>
        
          <ol>
            
              <li><span class="marker">2.1</span><a href="#propagate_const">Class template propagate_const</a>
        
          <ol>
            
              <li><span class="marker">2.1.1</span><a href="#propagate_const.general">Class template propagate_const general</a>
        
      </li>
            
              <li><span class="marker">2.1.2</span><a href="#propagate_const.synopsis">Header &lt;experimental/propagate_const&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">2.1.3</span><a href="#propagate_const.requirements">propagate_const requirements on T</a>
        
          <ol>
            
              <li><span class="marker">2.1.3.1</span><a href="#propagate_const.class_type_requirements">propagate_const requirements on class type T</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">2.1.4</span><a href="#propagate_const.ctor">propagate_const constructors</a>
        
      </li>
            
              <li><span class="marker">2.1.5</span><a href="#propagate_const.assignment">propagate_const assignment</a>
        
      </li>
            
              <li><span class="marker">2.1.6</span><a href="#propagate_const.const_observers">propagate_const const observers</a>
        
      </li>
            
              <li><span class="marker">2.1.7</span><a href="#propagate_const.non_const_observers">propagate_const non-const observers</a>
        
      </li>
            
              <li><span class="marker">2.1.8</span><a href="#propagate_const.modifiers">propagate_const modifiers</a>
        
      </li>
            
              <li><span class="marker">2.1.9</span><a href="#propagate_const.relational">propagate_const relational operators</a>
        
      </li>
            
              <li><span class="marker">2.1.10</span><a href="#propagate_const.algorithms">propagate_const specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">2.1.11</span><a href="#propagate_const.underlying">propagate_const underlying pointer access</a>
        
      </li>
            
              <li><span class="marker">2.1.12</span><a href="#propagate_const.hash">propagate_const hash support</a>
        
      </li>
            
              <li><span class="marker">2.1.13</span><a href="#propagate_const.comparison_function_objects">propagate_const comparison function objects</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">3</span><a href="#func">Function objects</a>
        
          <ol>
            
              <li><span class="marker">3.1</span><a href="#header.functional.synop">Header &lt;experimental/functional&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">3.2</span><a href="#func.not_fn">Function template not_fn</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">4</span><a href="#memory">Memory</a>
        
          <ol>
            
              <li><span class="marker">4.1</span><a href="#header.memory.synop">Header &lt;experimental/memory&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">4.2</span><a href="#memory.observer.ptr">Non-owning pointers</a>
        
          <ol>
            
              <li><span class="marker">4.2.1</span><a href="#memory.observer.ptr.overview">Class template observer_ptr overview</a>
        
      </li>
            
              <li><span class="marker">4.2.2</span><a href="#memory.observer.ptr.ctor">observer_ptr constructors</a>
        
      </li>
            
              <li><span class="marker">4.2.3</span><a href="#memory.observer.ptr.obs">observer_ptr observers</a>
        
      </li>
            
              <li><span class="marker">4.2.4</span><a href="#memory.observer.ptr.conv">observer_ptr conversions</a>
        
      </li>
            
              <li><span class="marker">4.2.5</span><a href="#memory.observer.ptr.mod">observer_ptr modifiers</a>
        
      </li>
            
              <li><span class="marker">4.2.6</span><a href="#memory.observer.ptr.special">observer_ptr specialized algorithms</a>
        
      </li>
            
              <li><span class="marker">4.2.7</span><a href="#memory.observer.ptr.hash">observer_ptr hash support</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5</span><a href="#container">Containers</a>
        
          <ol>
            
              <li><span class="marker">5.1</span><a href="#container.erasure">Uniform container erasure</a>
        
          <ol>
            
              <li><span class="marker">5.1.1</span><a href="#container.erasure.syn">Header synopsis</a>
        
      </li>
            
              <li><span class="marker">5.1.2</span><a href="#container.erasure.erase_if">Function template erase_if</a>
        
      </li>
            
              <li><span class="marker">5.1.3</span><a href="#container.erasure.erase">Function template erase</a>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">5.2</span><a href="#container.array">Class template array</a>
        
          <ol>
            
              <li><span class="marker">5.2.1</span><a href="#header.array.synop">Header &lt;experimental/array&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">5.2.2</span><a href="#container.array.creation">Array creation functions</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">6</span><a href="#iterator">Iterators library</a>
        
          <ol>
            
              <li><span class="marker">6.1</span><a href="#iterator.synopsis">Header &lt;experimental/iterator&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">6.2</span><a href="#iterator.ostream.joiner">Class template ostream_joiner</a>
        
          <ol>
            
              <li><span class="marker">6.2.1</span><a href="#iterator.ostream.joiner.cons">ostream_joiner constructor</a>
        
      </li>
            
              <li><span class="marker">6.2.2</span><a href="#iterator.ostream.joiner.ops">ostream_joiner operations</a>
        
      </li>
            
              <li><span class="marker">6.2.3</span><a href="#iterator.ostream.joiner.creation">ostream_joiner creation function</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">7</span><a href="#numeric">Numerics library</a>
        
          <ol>
            
              <li><span class="marker">7.1</span><a href="#numeric.ops">Generalized numeric operations</a>
        
          <ol>
            
              <li><span class="marker">7.1.1</span><a href="#numeric.ops.overview">Header &lt;experimental/numeric&gt; synopsis</a>
        
      </li>
            
              <li><span class="marker">7.1.2</span><a href="#numeric.ops.gcd">Greatest common divisor</a>
        
      </li>
            
              <li><span class="marker">7.1.3</span><a href="#numeric.ops.lcm">Least common multiple</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
              <li><span class="marker">8</span><a href="#reflection">Reflection library</a>
        
          <ol>
            
              <li><span class="marker">8.1</span><a href="#reflection.src_loc">Class source_location</a>
        
          <ol>
            
              <li><span class="marker">8.1.1</span><a href="#reflection.src_loc.intro">Header &lt;experimental/source_location&gt; synopsis</a>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      </li>
            
          </ol>
        
      
    </nav>
  </cxx-toc>

<cxx-clause id="general">
    

    <section>
      <header><span class="section-number">1</span> <h1 data-bookmark-label="1 General">General</h1> <span style="float:right"><a href="#general">[general]</a></span></header>
      
  
  <cxx-section id="general.scope">
    

    <section>
      <header><span class="section-number">1.1</span> <h1 data-bookmark-label="1.1 Scope">Scope</h1> <span style="float:right"><a href="#general.scope">[general.scope]</a></span></header>
      
    
    <p para_num="1" id="general.scope.1">This technical specification describes extensions to the C++
    Standard Library (<cxx-ref to="general.references"><a title="general.references" href="#general.references">1.2</a></cxx-ref>). These extensions are classes
    and functions that are likely to be used widely within a program
    and/or on the interface boundaries between libraries written by
    different organizations.</p>

    <p para_num="2" id="general.scope.2">This technical specification is non-normative. Some of the
    library components in this technical specification may be
    considered for standardization in a future version of C++, but
    they are not currently part of any C++ standard. Some of the
    components in this technical specification may never be
    standardized, and others may be standardized in a substantially
    changed form.</p>

    <p para_num="3" id="general.scope.3">The goal of this technical specification is to build more
    widespread existing practice for an expanded C++ standard
    library. It gives advice on extensions to those vendors who wish
    to provide them.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.references">
    

    <section>
      <header><span class="section-number">1.2</span> <h1 data-bookmark-label="1.2 Normative references">Normative references</h1> <span style="float:right"><a href="#general.references">[general.references]</a></span></header>
      
    

    <p para_num="1" id="general.references.1">The following referenced document is indispensable for the
    application of this document. For dated references, only the
    edition cited applies. For undated references, the latest edition
    of the referenced document (including any amendments) applies.</p>

    <ul>
      <li>ISO/IEC 14882:2014, <cite>Programming Languages — C++</cite>
      </li>
    </ul>

    <p para_num="2" id="general.references.2">ISO/IEC 14882:— is herein called the <dfn>C++ Standard</dfn>.
    References to clauses within the C++ Standard are written as "C++14
    §3.2". The library described in ISO/IEC 14882:— clauses 17–30 is
    herein called the <dfn>C++ Standard Library</dfn>.</p>

    <p para_num="3" id="general.references.3">Unless otherwise specified, the whole of the C++ Standard's Library
    introduction (<cxx-ref in="cxx" to="library">C++14 <span title="library">§17</span></cxx-ref>) is included into this
    Technical Specification by reference.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.namespaces">
    

    <section>
      <header><span class="section-number">1.3</span> <h1 data-bookmark-label="1.3 Namespaces, headers, and modifications to standard classes">Namespaces, headers, and modifications to standard classes</h1> <span style="float:right"><a href="#general.namespaces">[general.namespaces]</a></span></header>
      
    

    <p para_num="1" id="general.namespaces.1">Since the extensions described in this technical specification
    are experimental and not part of the C++ standard library, they
    should not be declared directly within namespace
    <code>std</code>.
    Unless otherwise specified, all components described in this technical specification either:
    </p>
    <ul>
      <li>modify an existing interface in the C++ Standard Library in-place,</li>
      <li>
        are declared in a namespace whose name appends <code>::experimental::fundamentals_v2</code>
        to a namespace defined in the C++ Standard Library,
        such as <code>std</code> or <code>std::chrono</code>, or
      </li>
      <li>
        are declared in a subnamespace of a namespace described in the previous bullet,
        whose name is not the same as an existing subnamespace of namespace <code>std</code>.
      </li>
    </ul>

    <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
      This TS does not define <code>std::experimental::fundamentals_v2::chrono</code>
      because the C++ Standard Library defines <code>std::chrono</code>.
      This TS does not define <code>std::pmr::experimental::fundamentals_v2</code>
      because the C++ Standard Library does not define <code>std::pmr</code>.
    
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>

    <p para_num="2" id="general.namespaces.2">Each header described in this technical
    specification shall import the contents of
    <code>std::experimental::fundamentals_v2</code> into
    <code>std::experimental</code> as if by</p>

    <pre><code>namespace std {
  namespace experimental {
    inline namespace fundamentals_v2 {}
  }
}</code></pre>

    <p para_num="3" id="general.namespaces.3">Unless otherwise specified, references to other entities
    described in this technical specification are assumed to be
    qualified with <code>std::experimental::fundamentals_v2::</code>,
    and references to entities described in the standard are assumed
    to be qualified with <code>std::</code>.</p>

    <p para_num="4" id="general.namespaces.4">Extensions that are expected to eventually be added to an
    existing header <code>&lt;meow&gt;</code> are provided inside the
    <code>&lt;experimental/meow&gt;</code> header, which shall include
    the standard contents of <code>&lt;meow&gt;</code> as if by</p>
    <pre><code>#include &lt;meow&gt;</code></pre>

    <p para_num="5" id="general.namespaces.5">New headers are also provided in the
    <code>&lt;experimental/&gt;</code> directory, but without such an
    <code>#include</code>.</p>

    <table role="presentation" is="cxx-table" id="tab.cxx.headers" class="list" columns="3">
    

    <caption>Table 1 — <wbr><span>C++ library headers</span></caption>
    
      
      <tbody><tr><td><ul><li><code>&lt;experimental/array&gt;</code></li><li><code>&lt;experimental/deque&gt;</code></li><li><code>&lt;experimental/forward_list&gt;</code></li><li><code>&lt;experimental/functional&gt;</code></li><li><code>&lt;experimental/iterator&gt;</code></li></ul></td><td><ul><li><code>&lt;experimental/list&gt;</code></li><li><code>&lt;experimental/map&gt;</code></li><li><code>&lt;experimental/memory&gt;</code></li><li><code>&lt;experimental/propagate_const&gt;</code></li><li><code>&lt;experimental/set&gt;</code></li></ul></td><td><ul><li><code>&lt;experimental/source_location&gt;</code></li><li><code>&lt;experimental/string&gt;</code></li><li><code>&lt;experimental/unordered_map&gt;</code></li><li><code>&lt;experimental/unordered_set&gt;</code></li><li><code>&lt;experimental/vector&gt;</code></li></ul></td></tr>
    </tbody>
  </table>
  
    </section>
  </cxx-section>

  <!--<cxx-section id="general.defns">
    <h1>Terms and definitions</h1>

    <p>For the purposes of this document, the terms and definitions
    given in the C++ Standard and the following apply.</p>

    <dl is="cxx-definition-section">
    </dl>
  </cxx-section>-->

  <cxx-section id="general.plans">
    

    <section>
      <header><span class="section-number">1.4</span> <h1 data-bookmark-label="1.4 Future plans (Informative)">Future plans (Informative)</h1> <span style="float:right"><a href="#general.plans">[general.plans]</a></span></header>
      
    

    <p para_num="1" id="general.plans.1">This section describes tentative plans for future versions of
    this technical specification and plans for moving content into
    future versions of the C++ Standard.</p>

    <p para_num="2" id="general.plans.2">The C++ committee intends to release a new version of this
    technical specification approximately every year, containing the
    library extensions we hope to add to a near-future version of the
    C++ Standard.  Future versions will define their contents in
    <code>std::experimental::fundamentals_v3</code>,
    <code>std::experimental::fundamentals_v4</code>, etc., with the
    most recent implemented version inlined into
    <code>std::experimental</code>.</p>

    <p para_num="3" id="general.plans.3">When an extension defined in this or a future version of this
    technical specification represents enough existing practice, it
    will be moved into the next version of the C++ Standard by
    removing the <code>experimental::fundamentals_v<var>N</var></code>
    segment of its namespace and by removing the
    <code>experimental/</code> prefix from its header's path.</p>
  
    </section>
  </cxx-section>

  <cxx-section id="general.feature.test">
    

    <section>
      <header><span class="section-number">1.5</span> <h1 data-bookmark-label="1.5 Feature-testing recommendations (Informative)">Feature-testing recommendations (Informative)</h1> <span style="float:right"><a href="#general.feature.test">[general.feature.test]</a></span></header>
      
    

    <p para_num="1" id="general.feature.test.1">
      For the sake of improved portability between partial implementations of various C++ standards,
      WG21 (the ISO technical committee for the C++ programming language) recommends
      that implementers and programmers follow the guidelines in this section concerning feature-test macros.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <a href="http://isocpp.org/std/standing-documents/sd-6-sg10-feature-test-recommendations">WG21's SD-6</a> makes similar recommendations for the C++ Standard itself.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <p para_num="2" id="general.feature.test.2">
      Implementers who provide a new standard feature should define a macro with the recommended name,
      in the same circumstances under which the feature is available (for example, taking into account relevant command-line options),
      to indicate the presence of support for that feature.
      Implementers should define that macro with the value specified in
      the most recent version of this technical specification that they have implemented.
      The recommended macro name is "<code>__cpp_lib_experimental_</code>" followed by the string in the "Macro Name Suffix" column.
    </p>

    <p para_num="3" id="general.feature.test.3">
      Programmers who wish to determine whether a feature is available in an implementation should base that determination on
      the presence of the header (determined with <code>__has_include(&lt;header/name&gt;)</code>) and
      the state of the macro with the recommended name.
      (The absence of a tested feature may result in a program with decreased functionality, or the relevant functionality may be provided in a different way.
      A program that strictly depends on support for a feature can just try to use the feature unconditionally;
      presumably, on an implementation lacking necessary support, translation will fail.)
    </p>

    <table is="cxx-table" class="column-rules">
    

    <caption>Table 2 — <wbr><span>Significant features in this technical specification</span></caption>
    
      

      <thead>
        <tr>
          <th>Doc. No.</th>
          <th>Title</th>
          <th>Primary Section</th>
          <th>Macro Name Suffix</th>
          <th>Value</th>
          <th>Header</th>
        </tr>
        <tr>
          <td>N4388</td>
          <td>A Proposal to Add a Const-Propagating Wrapper to the Standard Library
          </td><td><cxx-ref to="propagate_const"><a title="propagate_const" href="#propagate_const">2.1</a></cxx-ref>
          </td><td><code>propagate_const</code>
          </td><td>201504
          </td><td><code>&lt;experimental/propagate_const&gt;</code>
        </td></tr>
        <tr>
          <td>N4076</td>
          <td>A proposal to add a generalized callable negator
          </td><td><cxx-ref to="func.not_fn"><a title="func.not_fn" href="#func.not_fn">3.2</a></cxx-ref>
          </td><td><code>not_fn</code>
          </td><td>201406
          </td><td><code>&lt;experimental/functional&gt;</code>
        </td></tr>
        <tr>
          <td>N4282</td>
          <td>The World’s Dumbest Smart Pointer
          </td><td><cxx-ref to="memory.observer.ptr"><a title="memory.observer.ptr" href="#memory.observer.ptr">4.2</a></cxx-ref>
          </td><td><code>observer_ptr</code>
          </td><td>201411
          </td><td><code>&lt;experimental/memory&gt;</code>
        </td></tr>
        <tr>
          <td>N4273</td>
          <td>Uniform Container Erasure</td>
          <td><cxx-ref to="container.erasure"><a title="container.erasure" href="#container.erasure">5.1</a></cxx-ref></td>
          <td><code>erase_if</code></td>
          <td>201411</td>
          <td><code>&lt;experimental/vector&gt;</code></td>
        </tr>
        <tr>
          <td>N4315</td>
          <td>make_array</td>
          <td><cxx-ref to="container.array.creation"><a title="container.array.creation" href="#container.array.creation">5.2.2</a></cxx-ref></td>
          <td><code>make_array</code></td>
          <td>201504</td>
          <td><code>&lt;experimental/array&gt;</code></td>
        </tr>
        <tr>
          <td>N4257</td>
          <td>Delimited iterators</td>
          <td><cxx-ref to="iterator.ostream.joiner"><a title="iterator.ostream.joiner" href="#iterator.ostream.joiner">6.2</a></cxx-ref></td>
          <td><code>ostream_joiner</code></td>
          <td>201411</td>
          <td><code>&lt;experimental/iterator&gt;</code></td>
        </tr>
        <tr>
          <td>N4061</td>
          <td>Greatest Common Divisor and Least Common Multiple</td>
          <td><cxx-ref to="numeric.ops.gcd"><a title="numeric.ops.gcd" href="#numeric.ops.gcd">7.1.2</a></cxx-ref>, <cxx-ref to="numeric.ops.lcm"><a title="numeric.ops.lcm" href="#numeric.ops.lcm">7.1.3</a></cxx-ref></td>
          <td><code>gcd_lcm</code></td>
          <td>201411</td>
          <td><code>&lt;experimental/numeric&gt;</code></td>
        </tr>
        <tr>
          <td>N4519</td>
          <td>Source-Code Information Capture</td>
          <td><cxx-ref to="reflection.src_loc"><a title="reflection.src_loc" href="#reflection.src_loc">8.1</a></cxx-ref></td>
          <td><code>source_location</code></td>
          <td>201505</td>
          <td><code>&lt;experimental/source_location&gt;</code></td>
        </tr>
      </thead>

      <!-- These rows are in the same order as their feature appears in this document. -->
    
  </table>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="utilities">
    

    <section>
      <header><span class="section-number">2</span> <h1 data-bookmark-label="2 General utilities library">General utilities library</h1> <span style="float:right"><a href="#utilities">[utilities]</a></span></header>
      
  

  <cxx-section id="propagate_const">
    

    <section>
      <header><span class="section-number">2.1</span> <h1 data-bookmark-label="2.1 Class template propagate_const">Class template <code>propagate_const</code></h1> <span style="float:right"><a href="#propagate_const">[propagate_const]</a></span></header>
      
    

    <cxx-section id="propagate_const.general">
    

    <section>
      <header><span class="section-number">2.1.1</span> <h1 data-bookmark-label="2.1.1 Class template propagate_const general">Class template <code>propagate_const general</code></h1> <span style="float:right"><a href="#propagate_const.general">[propagate_const.general]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.general.1">
        <code>propagate_const</code> is a wrapper around a pointer-like object type <code>T</code>
        which treats the wrapped pointer as a pointer to <code>const</code> when
        the wrapper is accessed through a <code>const</code> access path.
      </p>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.synopsis">
    

    <section>
      <header><span class="section-number">2.1.2</span> <h1 data-bookmark-label="2.1.2 Header <experimental/propagate_const> synopsis">Header <code>&lt;experimental/propagate_const&gt;</code> synopsis</h1> <span style="float:right"><a href="#propagate_const.synopsis">[propagate_const.synopsis]</a></span></header>
      
      

<pre><code>namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {
    template &lt;class T&gt; class propagate_const {
    public:
      typedef remove_reference_t&lt;decltype(*declval&lt;T&amp;&gt;())&gt; element_type;

      <cxx-ref insynopsis="" to="propagate_const.ctor">// <i><a title="propagate_const.ctor" href="#propagate_const.ctor">2.1.4</a>, propagate_const constructors</i></cxx-ref>
      constexpr propagate_const() = default;
      propagate_const(const propagate_const&amp; p) = delete;
      constexpr propagate_const(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        <i>see below</i> constexpr propagate_const(U&amp;&amp; u);

      <cxx-ref insynopsis="" to="propagate_const.assignment">// <i><a title="propagate_const.assignment" href="#propagate_const.assignment">2.1.5</a>, propagate_const assignment</i></cxx-ref>
      propagate_const&amp; operator=(const propagate_const&amp; p) = delete;
      constexpr propagate_const&amp; operator=(propagate_const&amp;&amp; p) = default;
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(propagate_const&lt;U&gt;&amp;&amp; pu);
      template &lt;class U&gt;
        constexpr propagate_const&amp; operator=(U&amp;&amp; u);

      <cxx-ref insynopsis="" to="propagate_const.const_observers">// <i><a title="propagate_const.const_observers" href="#propagate_const.const_observers">2.1.6</a>, propagate_const const observers</i></cxx-ref>
      explicit constexpr operator bool() const;
      constexpr const element_type* operator-&gt;() const;
      constexpr operator const element_type*() const; // <i>Not always defined</i>
      constexpr const element_type&amp; operator*() const;
      constexpr const element_type* get() const;

      <cxx-ref insynopsis="" to="propagate_const.non_const_observers">// <i><a title="propagate_const.non_const_observers" href="#propagate_const.non_const_observers">2.1.7</a>, propagate_const non-const observers</i></cxx-ref>
      constexpr element_type* operator-&gt;();
      constexpr operator element_type*(); // <i>Not always defined</i>
      constexpr element_type&amp; operator*();
      constexpr element_type* get();

      <cxx-ref insynopsis="" to="propagate_const.modifiers">// <i><a title="propagate_const.modifiers" href="#propagate_const.modifiers">2.1.8</a>, propagate_const modifiers</i></cxx-ref>
      constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>);

    private:
      T t_; //<i>exposition only</i>
    };

    <cxx-ref insynopsis="" to="propagate_const.relational">// <i><a title="propagate_const.relational" href="#propagate_const.relational">2.1.9</a>, propagate_const relational operators</i></cxx-ref>
    template &lt;class T&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator==(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t);
    template &lt;class T&gt;
      constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u);

    template &lt;class T, class U&gt;
      constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);
    template &lt;class T, class U&gt;
      constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu);

    <cxx-ref insynopsis="" to="propagate_const.algorithms">// <i><a title="propagate_const.algorithms" href="#propagate_const.algorithms">2.1.10</a>, propagate_const specialized algorithms</i></cxx-ref>
    template &lt;class T&gt;
      constexpr void swap(propagate_const&lt;T&gt;&amp; pt, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>);

    <cxx-ref insynopsis="" to="propagate_const.underlying">// <i><a title="propagate_const.underlying" href="#propagate_const.underlying">2.1.11</a>, propagate_const underlying pointer access</i></cxx-ref>
    template &lt;class T&gt;
      constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept;
    template &lt;class T&gt;
      constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept;
  } // inline namespace fundamentals_v2
  } // namespace experimental

  <cxx-ref insynopsis="" to="propagate_const.hash">// <i><a title="propagate_const.hash" href="#propagate_const.hash">2.1.12</a>, propagate_const hash support</i></cxx-ref>
  template &lt;class T&gt; struct hash;
  template &lt;class T&gt;
    struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;

  <cxx-ref insynopsis="" to="propagate_const.comparison_function_objects">// <i><a title="propagate_const.comparison_function_objects" href="#propagate_const.comparison_function_objects">2.1.13</a>, propagate_const comparison function objects</i></cxx-ref>
  template &lt;class T&gt; struct equal_to;
  template &lt;class T&gt;
    struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct not_equal_to;
  template &lt;class T&gt;
    struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less;
  template &lt;class T&gt;
    struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater;
  template &lt;class T&gt;
    struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct less_equal;
  template &lt;class T&gt;
    struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
  template &lt;class T&gt; struct greater_equal;
  template &lt;class T&gt;
    struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;;
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.requirements">
    

    <section>
      <header><span class="section-number">2.1.3</span> <h1 data-bookmark-label="2.1.3 propagate_const requirements on T"><code>propagate_const</code> requirements on <code>T</code></h1> <span style="float:right"><a href="#propagate_const.requirements">[propagate_const.requirements]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.requirements.1">
        <code>T</code> shall be an object pointer type or a class type for which
        <code>decltype(*declval&lt;T&amp;&gt;())</code> is an lvalue reference; otherwise
        the program is ill-formed.
      </p>
      <p para_num="2" id="propagate_const.requirements.2">
        If <code>T</code> is an array type, reference type, pointer to function type or
        pointer to (possibly cv-qualified) <code>void</code>, then the program is
        ill-formed.
      </p>
      <p para_num="3" id="propagate_const.requirements.3">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    <code>propagate_const&lt;const int*&gt;</code> is well-formed
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>

      <cxx-section id="propagate_const.class_type_requirements">
    

    <section>
      <header><span class="section-number">2.1.3.1</span> <h1 data-bookmark-label="2.1.3.1 propagate_const requirements on class type T"><code>propagate_const</code> requirements on class type <code>T</code></h1> <span style="float:right"><a href="#propagate_const.class_type_requirements">[propagate_const.class_type_requirements]</a></span></header>
      
        

        <p para_num="1" id="propagate_const.class_type_requirements.1">
          If <code>T</code> is class
          type then it shall satisfy the following requirements. In this sub-clause
          <code>t</code> denotes a non-<code>const</code> lvalue of type <code>T</code>, <code>ct</code>
          is a <code>const T&amp;</code> bound to <code>t</code>,  <code>element_type</code> denotes
          an object type.
        </p>

        <p para_num="2" id="propagate_const.class_type_requirements.2">
          <code>T</code> and <code>const T</code> shall be contextually convertible to <code>bool</code>.
        </p>
        <p para_num="3" id="propagate_const.class_type_requirements.3">If <code>T</code> is implicitly convertible to <code>element_type*</code>,
          <code>(element_type*)t == t.get()</code> shall be <code>true</code>.
        </p>
        <p para_num="4" id="propagate_const.class_type_requirements.4">
          If <code>const T</code> is implicitly convertible to <code>const element_type*</code>,
          <code>(const element_type*)ct == ct.get()</code> shall be <code>true</code>.
        </p>

        <table is="cxx-table">
    

    <caption>Table 3 — <wbr><span>Requirements on class types <code>T</code></span></caption>
    
          
          <tbody><tr>
            <th>Expression</th>
            <th>Return type</th>
            <th>Pre-conditions</th>
            <th>Operational semantics</th>
          </tr>
          <tr>
            <td><code>t.get()</code></td>
            <td><code>element_type*</code></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td><code>ct.get()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code></code></td>
            <td><code>t.get() == ct.get()</code>.</td>
          </tr>
          <tr>
            <td><code>*t</code></td>
            <td><code>element_type&amp;</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>*t</code> refers to the same object as <code>*(t.get())</code></td>
          </tr>
          <tr>
            <td><code>*ct</code></td>
            <td><code>const element_type&amp;</code> or <code>element_type&amp;</code>
            </td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>*ct</code> refers to the same object as <code>*(ct.get())</code>
            </td></tr>
          <tr>
            <td><code>t.operator-&gt;()</code></td>
            <td><code>element_type*</code></td>
            <td><code>t.get() != nullptr</code></td>
            <td><code>t.operator-&gt;() == t.get()</code></td></tr>
          <tr>
            <td><code>ct.operator-&gt;()</code></td>
            <td><code>const element_type*</code> or <code>element_type*</code></td>
            <td><code>ct.get() != nullptr</code></td>
            <td><code>ct.operator-&gt;() == ct.get()</code></td></tr>
          <tr>
            <td><code>(bool)t</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)t</code> is equivalent to <code>t.get() != nullptr</code></td>
          </tr>
          <tr>
            <td><code>(bool)ct</code></td>
            <td><code>bool</code></td>
            <td><code></code></td>
            <td><code>(bool)ct</code> is equivalent to <code>ct.get() != nullptr</code></td>
          </tr>
        </tbody>
  </table>
      
    </section>
  </cxx-section>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.ctor">
    

    <section>
      <header><span class="section-number">2.1.4</span> <h1 data-bookmark-label="2.1.4 propagate_const constructors"><code>propagate_const</code> constructors</h1> <span style="float:right"><a href="#propagate_const.ctor">[propagate_const.ctor]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.ctor.1">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The following constructors are conditionally specified as
          <code>explicit</code>.  This is typically implemented by declaring two such
          constructors, of which at most one  participates in overload resolution.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>
      <cxx-function para_num="2" id="propagate_const.ctor.2">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(propagate_const&lt;U&gt;&amp;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="3" id="propagate_const.ctor.3">
    
    <dt>Remarks:</dt><dd>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="4" id="propagate_const.ctor.4">
    
    <dt>Effects:</dt><dd>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with the
          expression <code>std::move(pu.t_)</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.ctor.5">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
<i>see below</i> constexpr propagate_const(U&amp;&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="6" id="propagate_const.ctor.6">
    
    <dt>Remarks:</dt><dd>
          This constructor shall not participate in overload resolution unless
          <code>is_constructible_v&lt;T, U&amp;&amp;&gt;</code>
          and <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
          The constructor is specified as <code>explicit</code> if and only if
          <code>!is_convertible_v&lt;U&amp;&amp;, T&gt;.</code>
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="7" id="propagate_const.ctor.7">
    
    <dt>Effects:</dt><dd>
          Initializes <code>t_</code> as if
          direct-non-list-initializing an object of type <code>T</code> with
          the expression <code>std::forward&lt;U&gt;(u)</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.assignment">
    

    <section>
      <header><span class="section-number">2.1.5</span> <h1 data-bookmark-label="2.1.5 propagate_const assignment"><code>propagate_const</code> assignment</h1> <span style="float:right"><a href="#propagate_const.assignment">[propagate_const.assignment]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.assignment.1">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(propagate_const&lt;U&gt;&amp;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="2" id="propagate_const.assignment.2">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code>.
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="3" id="propagate_const.assignment.3">
    
    <dt>Effects:</dt><dd><code>t_ = std::move(pu.t_)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="4" id="propagate_const.assignment.4">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.assignment.5">
    
    <pre><code><cxx-signature>template &lt;class U&gt;
constexpr propagate_const operator=(U&amp;&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-remarks para_num="6" id="propagate_const.assignment.6">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>U</code> is implicitly convertible to <code>T</code> and
          <code>decay_t&lt;U&gt;</code> is not a specialization of <code>propagate_const</code>.
        </dd>
  </cxx-remarks>
        <cxx-effects para_num="7" id="propagate_const.assignment.7">
    
    <dt>Effects:</dt><dd><code>t_ = std::forward&lt;U&gt;(u)</code>.</dd>
  </cxx-effects>
        <cxx-returns para_num="8" id="propagate_const.assignment.8">
    
    <dt>Returns:</dt><dd><code>*this</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.const_observers">
    

    <section>
      <header><span class="section-number">2.1.6</span> <h1 data-bookmark-label="2.1.6 propagate_const const observers"><code>propagate_const</code> const observers</h1> <span style="float:right"><a href="#propagate_const.const_observers">[propagate_const.const_observers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.const_observers.1">
    
    <pre><code><cxx-signature>explicit constexpr operator bool() const</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="propagate_const.const_observers.2">
    
    <dt>Returns:</dt><dd><code>(bool)t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="propagate_const.const_observers.3">
    
    <pre><code><cxx-signature>constexpr const element_type* operator-&gt;() const</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="propagate_const.const_observers.4">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="5" id="propagate_const.const_observers.5">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="propagate_const.const_observers.6">
    
    <pre><code><cxx-signature>constexpr operator const element_type*() const</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="7" id="propagate_const.const_observers.7">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="8" id="propagate_const.const_observers.8">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>const element_type*</code>.
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="propagate_const.const_observers.9">
    
    <pre><code><cxx-signature>constexpr const element_type&amp; operator*() const</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="10" id="propagate_const.const_observers.10">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="11" id="propagate_const.const_observers.11">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="12" id="propagate_const.const_observers.12">
    
    <pre><code><cxx-signature>constexpr const element_type* get() const</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="13" id="propagate_const.const_observers.13">
    
    <dt>Returns:</dt><dd>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.non_const_observers">
    

    <section>
      <header><span class="section-number">2.1.7</span> <h1 data-bookmark-label="2.1.7 propagate_const non-const observers"><code>propagate_const</code> non-const observers</h1> <span style="float:right"><a href="#propagate_const.non_const_observers">[propagate_const.non_const_observers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.non_const_observers.1">
    
    <pre><code><cxx-signature>constexpr element_type* operator-&gt;()</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="propagate_const.non_const_observers.2">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="3" id="propagate_const.non_const_observers.3">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.non_const_observers.4">
    
    <pre><code><cxx-signature>constexpr operator element_type*()</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="5" id="propagate_const.non_const_observers.5">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
        <cxx-remarks para_num="6" id="propagate_const.non_const_observers.6">
    
    <dt>Remarks:</dt><dd>
          This function shall not participate in overload resolution unless
          <code>T</code> is an object pointer type or
          has an implicit conversion to <code>element_type*</code>.
        </dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.non_const_observers.7">
    
    <pre><code><cxx-signature>constexpr element_type&amp; operator*()</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="8" id="propagate_const.non_const_observers.8">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="9" id="propagate_const.non_const_observers.9">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="propagate_const.non_const_observers.10">
    
    <pre><code><cxx-signature>constexpr element_type* get()</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="11" id="propagate_const.non_const_observers.11">
    
    <dt>Returns:</dt><dd>
          <code>t_</code> if <code>T</code> is an object pointer type,
          otherwise <code>t_.get()</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.modifiers">
    

    <section>
      <header><span class="section-number">2.1.8</span> <h1 data-bookmark-label="2.1.8 propagate_const modifiers"><code>propagate_const</code> modifiers</h1> <span style="float:right"><a href="#propagate_const.modifiers">[propagate_const.modifiers]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.modifiers.1">
    
    <pre><code><cxx-signature>constexpr void swap(propagate_const&amp; pt) noexcept(<i>see below</i>)</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.modifiers.2">
          The constant-expression in the exception-specification is <code>noexcept(swap(t_, pt.t_))</code>.
        </p>

        <cxx-effects para_num="3" id="propagate_const.modifiers.3">
    
    <dt>Effects:</dt><dd><code>swap(t_, pt.t_)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.relational">
    

    <section>
      <header><span class="section-number">2.1.9</span> <h1 data-bookmark-label="2.1.9 propagate_const relational operators"><code>propagate_const</code> relational operators</h1> <span style="float:right"><a href="#propagate_const.relational">[propagate_const.relational]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.relational.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, nullptr_t)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="propagate_const.relational.2">
    
    <dt>Returns:</dt><dd><code>pt.t_ == nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="propagate_const.relational.3">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator==(nullptr_t, const propagate_const&lt;U&gt;&amp; pt)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="propagate_const.relational.4">
    
    <dt>Returns:</dt><dd><code>nullptr == pt.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="propagate_const.relational.5">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, nullptr_t)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="propagate_const.relational.6">
    
    <dt>Returns:</dt><dd><code>pt.t_ != nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.relational.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr bool operator!=(nullptr_t, const propagate_const&lt;T&gt;&amp; pt)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="propagate_const.relational.8">
    
    <dt>Returns:</dt><dd><code>nullptr != pt.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="propagate_const.relational.9">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="10" id="propagate_const.relational.10">
    
    <dt>Returns:</dt><dd><code>pt.t_ == pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="propagate_const.relational.11">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="12" id="propagate_const.relational.12">
    
    <dt>Returns:</dt><dd><code>pt.t_ != pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="propagate_const.relational.13">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="14" id="propagate_const.relational.14">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="propagate_const.relational.15">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="16" id="propagate_const.relational.16">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="propagate_const.relational.17">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="18" id="propagate_const.relational.18">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="propagate_const.relational.19">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="20" id="propagate_const.relational.20">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="21" id="propagate_const.relational.21">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="22" id="propagate_const.relational.22">
    
    <dt>Returns:</dt><dd><code>pt.t_ == u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="23" id="propagate_const.relational.23">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-returns para_num="24" id="propagate_const.relational.24">
    
    <dt>Returns:</dt><dd><code>pt.t_ != u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="25" id="propagate_const.relational.25">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="26" id="propagate_const.relational.26">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt; u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="27" id="propagate_const.relational.27">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="28" id="propagate_const.relational.28">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt; u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="29" id="propagate_const.relational.29">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="30" id="propagate_const.relational.30">
    
    <dt>Returns:</dt><dd><code>pt.t_ &lt;= u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="31" id="propagate_const.relational.31">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const propagate_const&lt;T&gt;&amp; pt, const U&amp; u)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="32" id="propagate_const.relational.32">
    
    <dt>Returns:</dt><dd><code>pt.t_ &gt;= u</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="33" id="propagate_const.relational.33">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator==(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="34" id="propagate_const.relational.34">
    
    <dt>Returns:</dt><dd><code>t == pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="35" id="propagate_const.relational.35">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator!=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="36" id="propagate_const.relational.36">
    
    <dt>Returns:</dt><dd><code>t != pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="37" id="propagate_const.relational.37">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="38" id="propagate_const.relational.38">
    
    <dt>Returns:</dt><dd><code>t &lt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="39" id="propagate_const.relational.39">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="40" id="propagate_const.relational.40">
    
    <dt>Returns:</dt><dd><code>t &gt; pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="41" id="propagate_const.relational.41">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&lt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="42" id="propagate_const.relational.42">
    
    <dt>Returns:</dt><dd><code>t &lt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="43" id="propagate_const.relational.43">
    
    <pre><code><cxx-signature>template &lt;class T, class U&gt;
constexpr bool operator&gt;=(const T&amp; t, const propagate_const&lt;U&gt;&amp; pu)</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="44" id="propagate_const.relational.44">
    
    <dt>Returns:</dt><dd><code>t &gt;= pu.t_</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
    <cxx-section id="propagate_const.algorithms">
    

    <section>
      <header><span class="section-number">2.1.10</span> <h1 data-bookmark-label="2.1.10 propagate_const specialized algorithms"><code>propagate_const</code> specialized algorithms</h1> <span style="float:right"><a href="#propagate_const.algorithms">[propagate_const.algorithms]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.algorithms.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr void swap(propagate_const&lt;T&gt;&amp; pt1, propagate_const&lt;T&gt;&amp; pt2) noexcept(<i>see below</i>)</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.algorithms.2">
          The constant-expression in the exception-specification is <code>noexcept(swap(pt1.t_, pt2.t_))</code>.
        </p>

        <cxx-effects para_num="3" id="propagate_const.algorithms.3">
    
    <dt>Effects:</dt><dd><code>swap(pt1.t_, pt2.t_)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.underlying">
    

    <section>
      <header><span class="section-number">2.1.11</span> <h1 data-bookmark-label="2.1.11 propagate_const underlying pointer access"><code>propagate_const</code> underlying pointer access</h1> <span style="float:right"><a href="#propagate_const.underlying">[propagate_const.underlying]</a></span></header>
      
      

      <p para_num="1" id="propagate_const.underlying.1">
        Access to the underlying object pointer type is
        through free functions rather than member functions.
        These functions are intended to resemble cast operations to encourage caution when using them.
      </p>

      <cxx-function para_num="2" id="propagate_const.underlying.2">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr const T&amp; get_underlying(const propagate_const&lt;T&gt;&amp; pt) noexcept</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="3" id="propagate_const.underlying.3">
    
    <dt>Returns:</dt><dd>
          a reference to the underlying object pointer type.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.underlying.4">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
constexpr T&amp; get_underlying(propagate_const&lt;T&gt;&amp; pt) noexcept</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="5" id="propagate_const.underlying.5">
    
    <dt>Returns:</dt><dd>
          a reference to the underlying object pointer type.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.hash">
    

    <section>
      <header><span class="section-number">2.1.12</span> <h1 data-bookmark-label="2.1.12 propagate_const hash support"><code>propagate_const</code> hash support</h1> <span style="float:right"><a href="#propagate_const.hash">[propagate_const.hash]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.hash.2">
          For an object <code>p</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>hash&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p)</code>
          shall evaluate to the same value as <code>hash&lt;T&gt;()(p.t_)</code>.
        </p>

        <cxx-requires para_num="3" id="propagate_const.hash.3">
    
    <dt>Requires:</dt><dd>
          The specialization <code>hash&lt;T&gt;</code> shall be well-formed and well-defined,
          and shall meet the requirements of class template hash.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="propagate_const.comparison_function_objects">
    

    <section>
      <header><span class="section-number">2.1.13</span> <h1 data-bookmark-label="2.1.13 propagate_const comparison function objects"><code>propagate_const</code> comparison function objects</h1> <span style="float:right"><a href="#propagate_const.comparison_function_objects">[propagate_const.comparison_function_objects]</a></span></header>
      
      

      <cxx-function para_num="1" id="propagate_const.comparison_function_objects.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="propagate_const.comparison_function_objects.2">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>equal_to&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="3" id="propagate_const.comparison_function_objects.3">
    
    <dt>Requires:</dt><dd>
          The specialization <code>equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="propagate_const.comparison_function_objects.4">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="5" id="propagate_const.comparison_function_objects.5">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>not_equal_to&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p, q)</code>
          shall evaluate to the same value as <code>not_equal_to&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires para_num="6" id="propagate_const.comparison_function_objects.6">
    
    <dt>Requires:</dt><dd>
          The specialization <code>not_equal_to&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="propagate_const.comparison_function_objects.7">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="8" id="propagate_const.comparison_function_objects.8">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="9" id="propagate_const.comparison_function_objects.9">
    
    <dt>Requires:</dt><dd>
          The specialization <code>less&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="10" id="propagate_const.comparison_function_objects.10">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="11" id="propagate_const.comparison_function_objects.11">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="12" id="propagate_const.comparison_function_objects.12">
    
    <dt>Requires:</dt><dd>
          The specialization <code>greater&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="propagate_const.comparison_function_objects.13">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="14" id="propagate_const.comparison_function_objects.14">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>less_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>less_equal&lt;T&gt;()(p.t_,
q.t_)</code>.
        </p>

        <cxx-requires para_num="15" id="propagate_const.comparison_function_objects.15">
    
    <dt>Requires:</dt><dd>
          The specialization <code>less_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="16" id="propagate_const.comparison_function_objects.16">
    
    <pre><code><cxx-signature>template &lt;class T&gt;
struct greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="17" id="propagate_const.comparison_function_objects.17">
          For objects <code>p, q</code> of type <code>propagate_const&lt;T&gt;</code>,
          <code>greater_equal&lt;experimental::fundamentals_v2::propagate_const&lt;T&gt;&gt;()(p,
q)</code>
          shall evaluate to the same value as <code>greater_equal&lt;T&gt;()(p.t_, q.t_)</code>.
        </p>

        <cxx-requires para_num="18" id="propagate_const.comparison_function_objects.18">
    
    <dt>Requires:</dt><dd>
          The specialization <code>greater_equal&lt;T&gt;</code> shall be well-formed and well-defined.
        </dd>
  </cxx-requires>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="func">
    

    <section>
      <header><span class="section-number">3</span> <h1 data-bookmark-label="3 Function objects">Function objects</h1> <span style="float:right"><a href="#func">[func]</a></span></header>
      
  

  <cxx-section id="header.functional.synop">
    

    <section>
      <header><span class="section-number">3.1</span> <h1 data-bookmark-label="3.1 Header <experimental/functional> synopsis">Header <code>&lt;experimental/functional&gt;</code> synopsis</h1> <span style="float:right"><a href="#header.functional.synop">[header.functional.synop]</a></span></header>
      
    

<pre><code>#include &lt;functional&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="func.not_fn">// <i><a title="func.not_fn" href="#func.not_fn">3.2</a>, Function template not_fn</i></cxx-ref>
  template &lt;class F&gt; unspecified not_fn(F&amp;&amp; f);

} // namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="func.not_fn">
    

    <section>
      <header><span class="section-number">3.2</span> <h1 data-bookmark-label="3.2 Function template not_fn">Function template <code>not_fn</code></h1> <span style="float:right"><a href="#func.not_fn">[func.not_fn]</a></span></header>
      
    

    <cxx-function para_num="1" id="func.not_fn.1">
    
    <pre><code><cxx-signature>template &lt;class F&gt; <em>unspecified</em> not_fn(F&amp;&amp; f);</cxx-signature></code></pre>

    <dl>
      
      

      <p para_num="2" id="func.not_fn.2">In the text that follows:</p>
      <ul>
        <li><code>FD</code> is the type <code>decay_t&lt;F&gt;</code>,</li>
        <li><code>fd</code> is an lvalue of type <code>FD</code> constructed from <code>std::forward&lt;F&gt;(f),</code></li>
        <li><code>fn</code> is a forwarding call wrapper created as a result of <code>not_fn(f)</code>,</li>
      </ul>
      <cxx-requires para_num="3" id="func.not_fn.3">
    
    <dt>Requires:</dt><dd>
        <code>is_constructible&lt;FD, F&gt;::value</code> shall be <code>true</code>.
        <code>fd</code> shall be a callable object (<cxx-ref in="cxx" to="func.def">C++14 <span title="func.def">§20.9.1</span></cxx-ref>).
      </dd>
  </cxx-requires>
      <cxx-returns para_num="4" id="func.not_fn.4">
    
    <dt>Returns:</dt><dd>
        A forwarding call wrapper <code>fn</code> such that the expression <code>fn(a1, a2, ..., aN)</code>
        is equivalent to <code>!<em>INVOKE</em>(fd, a1, a2, ..., aN)</code> (<cxx-ref in="cxx" to="func.require">C++14 <span title="func.require">§20.9.2</span></cxx-ref>).
      </dd>
  </cxx-returns>
      <cxx-throws para_num="5" id="func.not_fn.5">
    
    <dt>Throws:</dt><dd>Nothing unless the construction of <code>fd</code> throws an exception.</dd>
  </cxx-throws>
      <cxx-remarks para_num="6" id="func.not_fn.6">
    
    <dt>Remarks:</dt><dd>
        The return type shall satisfy the requirements of <code>MoveConstructible</code>.
        If <code>FD</code> satisfies the requirements of <code>CopyConstructible</code>, then
        the return type shall satisfy the requirements of <code>CopyConstructible</code>.
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    This implies that <code>FD</code> is MoveConstructible.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </dd>
  </cxx-remarks>
      <p para_num="7" id="func.not_fn.7"><cxx-note><span class="nowrap">[ <em>Note:</em></span>
    Function template <code>not_fn</code> can usually provide a better solution than using the negators <code>not1</code> and <code>not2</code>
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note></p>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="memory">
    

    <section>
      <header><span class="section-number">4</span> <h1 data-bookmark-label="4 Memory">Memory</h1> <span style="float:right"><a href="#memory">[memory]</a></span></header>
      
  

  <cxx-section id="header.memory.synop">
    

    <section>
      <header><span class="section-number">4.1</span> <h1 data-bookmark-label="4.1 Header <experimental/memory> synopsis">Header &lt;experimental/memory&gt; synopsis</h1> <span style="float:right"><a href="#header.memory.synop">[header.memory.synop]</a></span></header>
      
    

<pre><code>#include &lt;memory&gt;

namespace std {
  namespace experimental {
  inline namespace fundamentals_v2 {

    <cxx-ref insynopsis="" to="memory.observer.ptr">// <i><a title="memory.observer.ptr" href="#memory.observer.ptr">4.2</a>, Non-owning pointers</i></cxx-ref>
    template &lt;class W&gt; class observer_ptr;

    <cxx-ref insynopsis="" to="memory.observer.ptr.special">// <i><a title="memory.observer.ptr.special" href="#memory.observer.ptr.special">4.2.6</a>, observer_ptr specialized algorithms</i></cxx-ref>
    template &lt;class W&gt;
    void swap(observer_ptr&lt;W&gt;&amp;, observer_ptr&lt;W&gt;&amp;) noexcept;
    template &lt;class W&gt;
    observer_ptr&lt;W&gt; make_observer(W*) noexcept;
    // (in)equality operators
    template &lt;class W1, class W2&gt;
    bool operator==(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

    template &lt;class W1, class W2&gt;
    bool operator!=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W&gt;
    bool operator==(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    bool operator!=(observer_ptr&lt;W&gt;, nullptr_t) noexcept;
    template &lt;class W&gt;
    bool operator==(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    template &lt;class W&gt;
    bool operator!=(nullptr_t, observer_ptr&lt;W&gt;) noexcept;
    // ordering operators
    template &lt;class W1, class W2&gt;
    bool operator&lt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&gt;(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&lt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);
    template &lt;class W1, class W2&gt;
    bool operator&gt;=(observer_ptr&lt;W1&gt;, observer_ptr&lt;W2&gt;);

  } // inline namespace fundamentals_v2
  } // namespace experimental

<cxx-ref insynopsis="" to="memory.observer.ptr.hash">// <i><a title="memory.observer.ptr.hash" href="#memory.observer.ptr.hash">4.2.7</a>, observer_ptr hash support</i></cxx-ref>
template &lt;class T&gt; struct hash;
template &lt;class T&gt; struct hash&lt;experimental::observer_ptr&lt;T&gt;&gt;;

} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="memory.observer.ptr">
    

    <section>
      <header><span class="section-number">4.2</span> <h1 data-bookmark-label="4.2 Non-owning pointers">Non-owning pointers</h1> <span style="float:right"><a href="#memory.observer.ptr">[memory.observer.ptr]</a></span></header>
      
    

    <p para_num="1" id="memory.observer.ptr.1">
      A non-owning pointer, known as an <dfn>observer</dfn>, is an object <code>o</code> that stores a pointer to a second object, <code>w</code>.
      In this context, <code>w</code> is known as a <dfn>watched</dfn> object.
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    There is no watched object when the stored pointer is <code>nullptr</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      An observer takes no responsibility or ownership of any kind for its watched object, if any;
      in particular, there is no inherent relationship between the lifetimes of <code>o</code> and <code>w</code>.
    </p>

    <p para_num="2" id="memory.observer.ptr.2">
      Specializations of <code>observer_ptr</code> shall meet the requirements of a <code>CopyConstructible</code> and <code>CopyAssignable</code> type.
      The template parameter <code>W</code> of an <code>observer_ptr</code> shall not be a reference type, but may be an incomplete type.
    </p>

    <p para_num="3" id="memory.observer.ptr.3">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The uses of <code>observer_ptr</code> include clarity of interface specification in new code,
      and interoperability with pointer-based legacy code.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <cxx-section id="memory.observer.ptr.overview">
    

    <section>
      <header><span class="section-number">4.2.1</span> <h1 data-bookmark-label="4.2.1 Class template observer_ptr overview">Class template <code>observer_ptr</code> overview</h1> <span style="float:right"><a href="#memory.observer.ptr.overview">[memory.observer.ptr.overview]</a></span></header>
      
      

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template &lt;class W&gt; class observer_ptr {
  public:
    // publish our template parameter and variations thereof
    using element_type = W;
    using pointer = add_pointer_t&lt;W&gt;;            <i>// exposition-only</i>
    using reference = add_lvalue_reference_t&lt;W&gt;; <i>// exposition-only</i>

    <cxx-ref insynopsis="" to="memory.observer.ptr.ctor">// <i><a title="memory.observer.ptr.ctor" href="#memory.observer.ptr.ctor">4.2.2</a>, observer_ptr constructors</i></cxx-ref>
    // default c’tor
    constexpr observer_ptr() noexcept;

    // pointer-accepting c’tors
    constexpr observer_ptr(nullptr_t) noexcept;
    constexpr explicit observer_ptr(pointer) noexcept;

    // copying c’tors (in addition to compiler-generated copy c’tor)
    template &lt;class W2&gt; constexpr observer_ptr(observer_ptr&lt;W2&gt;) noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.obs">// <i><a title="memory.observer.ptr.obs" href="#memory.observer.ptr.obs">4.2.3</a>, observer_ptr observers</i></cxx-ref>
    constexpr pointer get() const noexcept;
    constexpr reference operator*() const;
    constexpr pointer operator-&gt;() const noexcept;
    constexpr explicit operator bool() const noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.conv">// <i><a title="memory.observer.ptr.conv" href="#memory.observer.ptr.conv">4.2.4</a>, observer_ptr conversions</i></cxx-ref>
    constexpr explicit operator pointer() const noexcept;

    <cxx-ref insynopsis="" to="memory.observer.ptr.mod">// <i><a title="memory.observer.ptr.mod" href="#memory.observer.ptr.mod">4.2.5</a>, observer_ptr modifiers</i></cxx-ref>
    constexpr pointer release() noexcept;
    constexpr void reset(pointer = nullptr) noexcept;
    constexpr void swap(observer_ptr&amp;) noexcept;
  }; // observer_ptr&lt;&gt;

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.ctor">
    

    <section>
      <header><span class="section-number">4.2.2</span> <h1 data-bookmark-label="4.2.2 observer_ptr constructors"><code>observer_ptr</code> constructors</h1> <span style="float:right"><a href="#memory.observer.ptr.ctor">[memory.observer.ptr.ctor]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.ctor.1">
    
    <pre><code><cxx-signature>constexpr observer_ptr() noexcept;</cxx-signature><cxx-signature>constexpr observer_ptr(nullptr_t) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-effects para_num="2" id="memory.observer.ptr.ctor.2">
    
    <dt>Effects:</dt><dd>Constructs an observer_ptr object that has no corresponding watched object.</dd>
  </cxx-effects>
        <cxx-postconditions para_num="3" id="memory.observer.ptr.ctor.3">
    
    <dt>Postconditions:</dt><dd><code>get() == nullptr</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.observer.ptr.ctor.4">
    
    <pre><code><cxx-signature>constexpr explicit observer_ptr(pointer other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="5" id="memory.observer.ptr.ctor.5">
    
    <dt>Postconditions:</dt><dd><code>get() == other</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.observer.ptr.ctor.6">
    
    <pre><code><cxx-signature>template &lt;class W2&gt; constexpr observer_ptr(observer_ptr&lt;W2&gt; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="7" id="memory.observer.ptr.ctor.7">
    
    <dt>Postconditions:</dt><dd><code>get() == other.get()</code>.</dd>
  </cxx-postconditions>
        <cxx-remarks para_num="8" id="memory.observer.ptr.ctor.8">
    
    <dt>Remarks:</dt><dd>This constructor shall not participate in overload resolution unless <code>W2*</code> is convertible to <code>W*</code>.</dd>
  </cxx-remarks>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.obs">
    

    <section>
      <header><span class="section-number">4.2.3</span> <h1 data-bookmark-label="4.2.3 observer_ptr observers"><code>observer_ptr</code> observers</h1> <span style="float:right"><a href="#memory.observer.ptr.obs">[memory.observer.ptr.obs]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.obs.1">
    
    <pre><code><cxx-signature>constexpr pointer get() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.observer.ptr.obs.2">
    
    <dt>Returns:</dt><dd>The stored pointer.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.observer.ptr.obs.3">
    
    <pre><code><cxx-signature>constexpr reference operator*() const;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="4" id="memory.observer.ptr.obs.4">
    
    <dt>Requires:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-requires>
        <cxx-returns para_num="5" id="memory.observer.ptr.obs.5">
    
    <dt>Returns:</dt><dd><code>*get()</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="6" id="memory.observer.ptr.obs.6">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.observer.ptr.obs.7">
    
    <pre><code><cxx-signature>constexpr pointer operator-&gt;() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="memory.observer.ptr.obs.8">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.observer.ptr.obs.9">
    
    <pre><code><cxx-signature>constexpr explicit operator bool() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="10" id="memory.observer.ptr.obs.10">
    
    <dt>Returns:</dt><dd><code>get() != nullptr</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.conv">
    

    <section>
      <header><span class="section-number">4.2.4</span> <h1 data-bookmark-label="4.2.4 observer_ptr conversions"><code>observer_ptr</code> conversions</h1> <span style="float:right"><a href="#memory.observer.ptr.conv">[memory.observer.ptr.conv]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.conv.1">
    
    <pre><code><cxx-signature>constexpr explicit operator pointer() const noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="memory.observer.ptr.conv.2">
    
    <dt>Returns:</dt><dd><code>get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.mod">
    

    <section>
      <header><span class="section-number">4.2.5</span> <h1 data-bookmark-label="4.2.5 observer_ptr modifiers"><code>observer_ptr</code> modifiers</h1> <span style="float:right"><a href="#memory.observer.ptr.mod">[memory.observer.ptr.mod]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.mod.1">
    
    <pre><code><cxx-signature>constexpr pointer release() noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="2" id="memory.observer.ptr.mod.2">
    
    <dt>Postconditions:</dt><dd><code>get() == nullptr</code>.</dd>
  </cxx-postconditions>
        <cxx-returns para_num="3" id="memory.observer.ptr.mod.3">
    
    <dt>Returns:</dt><dd>The value <code>get()</code> had at the start of the call to <code>release</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="4" id="memory.observer.ptr.mod.4">
    
    <pre><code><cxx-signature>constexpr void reset(pointer p = nullptr) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-postconditions para_num="5" id="memory.observer.ptr.mod.5">
    
    <dt>Postconditions:</dt><dd><code>get() == p</code>.</dd>
  </cxx-postconditions>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="6" id="memory.observer.ptr.mod.6">
    
    <pre><code><cxx-signature>constexpr void swap(observer_ptr&amp; other) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="7" id="memory.observer.ptr.mod.7">
    
    <dt>Effects:</dt><dd>Invokes <code>swap</code> on the stored pointers of <code>*this</code> and <code>other</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.special">
    

    <section>
      <header><span class="section-number">4.2.6</span> <h1 data-bookmark-label="4.2.6 observer_ptr specialized algorithms"><code>observer_ptr</code> specialized algorithms</h1> <span style="float:right"><a href="#memory.observer.ptr.special">[memory.observer.ptr.special]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.special.1">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
void swap(observer_ptr&lt;W&gt;&amp; p1, observer_ptr&lt;W&gt;&amp; p2) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="memory.observer.ptr.special.2">
    
    <dt>Effects:</dt><dd><code>p1.swap(p2)</code>.</dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="memory.observer.ptr.special.3">
    
    <pre><code><cxx-signature>template &lt;class W&gt; observer_ptr&lt;W&gt; make_observer(W* p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="memory.observer.ptr.special.4">
    
    <dt>Returns:</dt><dd><code>observer_ptr&lt;W&gt;{p}</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="memory.observer.ptr.special.5">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator==(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="memory.observer.ptr.special.6">
    
    <dt>Returns:</dt><dd><code>p1.get() == p2.get()</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="7" id="memory.observer.ptr.special.7">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator!=(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="8" id="memory.observer.ptr.special.8">
    
    <dt>Returns:</dt><dd><code>not (p1 == p2)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="9" id="memory.observer.ptr.special.9">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator==(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;</cxx-signature><cxx-signature>template &lt;class W&gt;
bool operator==(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="10" id="memory.observer.ptr.special.10">
    
    <dt>Returns:</dt><dd><code>not p</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="11" id="memory.observer.ptr.special.11">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator!=(observer_ptr&lt;W&gt; p, nullptr_t) noexcept;</cxx-signature><cxx-signature>template &lt;class W&gt;
bool operator!=(nullptr_t, observer_ptr&lt;W&gt; p) noexcept;</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="12" id="memory.observer.ptr.special.12">
    
    <dt>Returns:</dt><dd><code>(bool)p</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="13" id="memory.observer.ptr.special.13">
    
    <pre><code><cxx-signature>template &lt;class W1, class W2&gt;
bool operator&lt;(observer_ptr&lt;W1&gt; p1, observer_ptr&lt;W2&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="14" id="memory.observer.ptr.special.14">
    
    <dt>Returns:</dt><dd>
          <code>less&lt;W3&gt;()(p1.get(), p2.get())</code>,
          where <code>W3</code> is the composite pointer type (<cxx-ref in="cxx" to="expr">C++14 <span title="expr">§5</span></cxx-ref>) of <code>W1*</code> and <code>W2*</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="15" id="memory.observer.ptr.special.15">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator&gt;(observer_ptr&lt;W&gt; p1, observer_ptr&lt;W&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="16" id="memory.observer.ptr.special.16">
    
    <dt>Returns:</dt><dd><code>p2 &lt; p1</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="17" id="memory.observer.ptr.special.17">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator&lt;=(observer_ptr&lt;W&gt; p1, observer_ptr&lt;W&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

         <cxx-returns para_num="18" id="memory.observer.ptr.special.18">
    
    <dt>Returns:</dt><dd><code>not (p2 &lt; p1)</code>.</dd>
  </cxx-returns>
        
    </dl>
  </cxx-function>

      <cxx-function para_num="19" id="memory.observer.ptr.special.19">
    
    <pre><code><cxx-signature>template &lt;class W&gt;
bool operator&gt;=(observer_ptr&lt;W&gt; p1, observer_ptr&lt;W&gt; p2);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="20" id="memory.observer.ptr.special.20">
    
    <dt>Returns:</dt><dd><code>not (p1 &lt; p2)</code>.</dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="memory.observer.ptr.hash">
    

    <section>
      <header><span class="section-number">4.2.7</span> <h1 data-bookmark-label="4.2.7 observer_ptr hash support"><code>observer_ptr</code> hash support</h1> <span style="float:right"><a href="#memory.observer.ptr.hash">[memory.observer.ptr.hash]</a></span></header>
      
      

      <cxx-function para_num="1" id="memory.observer.ptr.hash.1">
    
    <pre><code><cxx-signature>template &lt;class T&gt; struct hash&lt;experimental::observer_ptr&lt;T&gt;&gt;;</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="memory.observer.ptr.hash.2">
          The template specialization shall meet the requirements of class template <code>hash</code> (<cxx-ref in="cxx" to="unord.hash">C++14 <span title="unord.hash">§20.9.12</span></cxx-ref>).
          For an object <code>p</code> of type <code>observer_ptr&lt;T&gt;</code>,
          <code>hash&lt;observer_ptr&lt;T&gt;&gt;()(p)</code> shall evaluate to the same value as <code>hash&lt;T*&gt;()(p.get())</code>.
        </p>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="container">
    

    <section>
      <header><span class="section-number">5</span> <h1 data-bookmark-label="5 Containers">Containers</h1> <span style="float:right"><a href="#container">[container]</a></span></header>
      
  

  <cxx-section id="container.erasure">
    

    <section>
      <header><span class="section-number">5.1</span> <h1 data-bookmark-label="5.1 Uniform container erasure">Uniform container erasure</h1> <span style="float:right"><a href="#container.erasure">[container.erasure]</a></span></header>
      
    

    <cxx-section id="container.erasure.syn">
    

    <section>
      <header><span class="section-number">5.1.1</span> <h1 data-bookmark-label="5.1.1 Header synopsis">Header synopsis</h1> <span style="float:right"><a href="#container.erasure.syn">[container.erasure.syn]</a></span></header>
      
      

      <p para_num="1" id="container.erasure.syn.1">
        For brevity, this section specifies the contents of 9 headers,
        each of which behaves as described by <cxx-ref to="general.namespaces"><a title="general.namespaces" href="#general.namespaces">1.3</a></cxx-ref>.
      </p>

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.erasure.erase_if">// <i><a title="container.erasure.erase_if" href="#container.erasure.erase_if">5.1.2</a>, Function template erase_if</i></cxx-ref>
  <cxx-ref insynopsis="" to="container.erasure.erase">// <i><a title="container.erasure.erase" href="#container.erasure.erase">5.1.3</a>, Function template erase</i></cxx-ref>

  // &lt;experimental/string&gt;
  template &lt;class charT, class traits, class A, class Predicate&gt;
    void erase_if(basic_string&lt;charT, traits, A&gt;&amp; c, Predicate pred);
  template &lt;class charT, class traits, class A, class U&gt;
    void erase(basic_string&lt;charT, traits, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/deque&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(deque&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(deque&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/vector&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(vector&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(vector&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/forward_list&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(forward_list&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(forward_list&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/list&gt;
  template &lt;class T, class A, class Predicate&gt;
    void erase_if(list&lt;T, A&gt;&amp; c, Predicate pred);
  template &lt;class T, class A, class U&gt;
    void erase(list&lt;T, A&gt;&amp; c, const U&amp; value);

  // &lt;experimental/map&gt;
  template &lt;class K, class T, class C, class A, class Predicate&gt;
    void erase_if(map&lt;K, T, C, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class T, class C, class A, class Predicate&gt;
    void erase_if(multimap&lt;K, T, C, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/set&gt;
  template &lt;class K, class C, class A, class Predicate&gt;
    void erase_if(set&lt;K, C, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class C, class A, class Predicate&gt;
    void erase_if(multiset&lt;K, C, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/unordered_map&gt;
  template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);

  // &lt;experimental/unordered_set&gt;
  template &lt;class K, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);
  template &lt;class K, class H, class P, class A, class Predicate&gt;
    void erase_if(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="container.erasure.erase_if">
    

    <section>
      <header><span class="section-number">5.1.2</span> <h1 data-bookmark-label="5.1.2 Function template erase_if">Function template <code>erase_if</code></h1> <span style="float:right"><a href="#container.erasure.erase_if">[container.erasure.erase_if]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.erasure.erase_if.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class A, class Predicate&gt;
void erase_if(basic_string&lt;charT, traits, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(deque&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(vector&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        <cxx-effects para_num="2" id="container.erasure.erase_if.2">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.erase(remove_if(c.begin(), c.end(), pred), c.end());</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="container.erasure.erase_if.3">
    
    <pre><code><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(forward_list&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class T, class A, class Predicate&gt;
void erase_if(list&lt;T, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        <cxx-effects para_num="4" id="container.erasure.erase_if.4">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.remove_if(pred);</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="container.erasure.erase_if.5">
    
    <pre><code><cxx-signature>template &lt;class K, class T, class C, class A, class Predicate&gt;
void erase_if(map&lt;K, T, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class C, class A, class Predicate&gt;
void erase_if(multimap&lt;K, T, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class C, class A, class Predicate&gt;
void erase_if(set&lt;K, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class C, class A, class Predicate&gt;
void erase_if(multiset&lt;K, C, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_map&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class T, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_multimap&lt;K, T, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_set&lt;K, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature><cxx-signature>template &lt;class K, class H, class P, class A, class Predicate&gt;
void erase_if(unordered_multiset&lt;K, H, P, A&gt;&amp; c, Predicate pred);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        
        
        
        
        
        <cxx-effects para_num="6" id="container.erasure.erase_if.6">
    
    <dt>Effects:</dt><dd>Equivalent to:
<pre><code>for (auto i = c.begin(), last = c.end(); i != last; ) {
  if (pred(*i)) {
    i = c.erase(i);
  } else {
    ++i;
  }
}</code></pre></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="container.erasure.erase">
    

    <section>
      <header><span class="section-number">5.1.3</span> <h1 data-bookmark-label="5.1.3 Function template erase">Function template erase</h1> <span style="float:right"><a href="#container.erasure.erase">[container.erasure.erase]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.erasure.erase.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class A, class U&gt;
void erase(basic_string&lt;charT, traits, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(deque&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(vector&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature></code></pre>

    <dl>
      
        
        
        
        <cxx-effects para_num="2" id="container.erasure.erase.2">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>c.erase(remove(c.begin(), c.end(), value), c.end());</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="container.erasure.erase.3">
    
    <pre><code><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(forward_list&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature><cxx-signature>template &lt;class T, class A, class U&gt;
void erase(list&lt;T, A&gt;&amp; c, const U&amp; value);</cxx-signature></code></pre>

    <dl>
      
        
        
        <cxx-effects para_num="4" id="container.erasure.erase.4">
    
    <dt>Effects:</dt><dd>Equivalent to: <code>erase_if(c, [&amp;](auto&amp; elem) { return elem == value; });</code></dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    
        Overloads of <code>erase()</code> for associative containers and unordered associative containers are intentionally not provided.
      
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

  <cxx-section id="container.array">
    

    <section>
      <header><span class="section-number">5.2</span> <h1 data-bookmark-label="5.2 Class template array">Class template <code>array</code></h1> <span style="float:right"><a href="#container.array">[container.array]</a></span></header>
      
    

    <cxx-section id="header.array.synop">
    

    <section>
      <header><span class="section-number">5.2.1</span> <h1 data-bookmark-label="5.2.1 Header <experimental/array> synopsis">Header &lt;experimental/array&gt; synopsis</h1> <span style="float:right"><a href="#header.array.synop">[header.array.synop]</a></span></header>
      
      

      <pre><code>#include &lt;array&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="container.array.creation">// <i><a title="container.array.creation" href="#container.array.creation">5.2.2</a>, Array creation functions</i></cxx-ref>
  template &lt;class D = void, class... Types&gt;
    constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);
  template &lt;class T, size_t N&gt;
    constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="container.array.creation">
    

    <section>
      <header><span class="section-number">5.2.2</span> <h1 data-bookmark-label="5.2.2 Array creation functions">Array creation functions</h1> <span style="float:right"><a href="#container.array.creation">[container.array.creation]</a></span></header>
      
      

      <cxx-function para_num="1" id="container.array.creation.1">
    
    <pre><code><cxx-signature>template &lt;class D = void, class... Types&gt;
&nbsp;&nbsp;constexpr array&lt;<i>VT</i>, sizeof...(Types)&gt; make_array(Types&amp;&amp;... t);</cxx-signature></code></pre>

    <dl>
      
        

        <p para_num="2" id="container.array.creation.2">
          Let <em>Ui</em> be <code>decay_t&lt;</code><em>Ti</em><code>&gt;</code> for each <em>Ti</em> in <code>Types</code>.
        </p>
        <cxx-remarks para_num="3" id="container.array.creation.3">
    
    <dt>Remarks:</dt><dd>
          The program is ill-formed if <code>D</code> is <code>void</code> and at least one <em>Ui</em> is a specialization of <code>reference_wrapper</code>.
        </dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="container.array.creation.4">
    
    <dt>Returns:</dt><dd>
          <code>array&lt;<var>VT</var>, sizeof...(Types)&gt;{ std::forward&lt;Types&gt;(t)... }</code>, where <code><var>VT</var></code> is <code>common_type_t&lt;Types...&gt;</code> if <code>D</code> is <code>void</code>, otherwise <code><var>VT</var></code> is <code>D</code>.
        </dd>
  </cxx-returns>

        <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
<pre><code>int i = 1; int&amp; ri = i;
auto a1 = make_array(i, ri);         // a1<i> is of type </i>array&lt;int, 2&gt;
auto a2 = make_array(i, ri, 42L);    // a2<i> is of type </i>array&lt;long, 3&gt;
auto a3 = make_array&lt;long&gt;(i, ri);   // a3<i> is of type </i>array&lt;long, 2&gt;
auto a4 = make_array&lt;long&gt;();        // a4<i> is of type </i>array&lt;long, 0&gt;
auto a5 = make_array();              // <i>ill-formed</i></code></pre>
        
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="container.array.creation.5">
    
    <pre><code><cxx-signature>template &lt;class T, size_t N&gt;
constexpr array&lt;remove_cv_t&lt;T&gt;, N&gt; to_array(T (&amp;a)[N]);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="6" id="container.array.creation.6">
    
    <dt>Returns:</dt><dd>
          An <code>array&lt;remove_cv_t&lt;T&gt;, N&gt;</code> such that each element is copy-initialized with the corresponding element of <code>a</code>.
        </dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="iterator">
    

    <section>
      <header><span class="section-number">6</span> <h1 data-bookmark-label="6 Iterators library">Iterators library</h1> <span style="float:right"><a href="#iterator">[iterator]</a></span></header>
      
  

  <cxx-section id="iterator.synopsis">
    

    <section>
      <header><span class="section-number">6.1</span> <h1 data-bookmark-label="6.1 Header <experimental/iterator> synopsis">Header <code>&lt;experimental/iterator&gt;</code> synopsis</h1> <span style="float:right"><a href="#iterator.synopsis">[iterator.synopsis]</a></span></header>
      
    

<pre><code>#include &lt;iterator&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="iterator.ostream.joiner">// <i><a title="iterator.ostream.joiner" href="#iterator.ostream.joiner">6.2</a>, Class template ostream_joiner</i></cxx-ref>
  template &lt;class DelimT, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
      class ostream_joiner;
  template &lt;class charT, class traits, class DelimT&gt;
    ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;
    make_ostream_joiner(basic_ostream&lt;charT, traits&gt;&amp; os, DelimT&amp;&amp; delimiter);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
  
    </section>
  </cxx-section>

  <cxx-section id="iterator.ostream.joiner">
    

    <section>
      <header><span class="section-number">6.2</span> <h1 data-bookmark-label="6.2 Class template ostream_joiner">Class template <code>ostream_joiner</code></h1> <span style="float:right"><a href="#iterator.ostream.joiner">[iterator.ostream.joiner]</a></span></header>
      
    

    <p para_num="1" id="iterator.ostream.joiner.1">
      <code>ostream_joiner</code> writes (using <code>operator&lt;&lt;</code>) successive elements onto the output stream from which it was constructed.
      The delimiter that it was constructed with is written to the stream between every two <code>T</code>s that are written.
      It is not possible to get a value out of the output iterator.
      Its only use is as an output iterator in situations like
    </p>
    <pre><code>while (first != last)
  *result++ = *first++;</code></pre>

  <p para_num="2" id="iterator.ostream.joiner.2">
    <code>ostream_joiner</code> is defined as
  </p>
<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  template &lt;class DelimT, class charT = char, class traits = char_traits&lt;charT&gt; &gt;
  class ostream_joiner {
  public:
    typedef charT char_type;
    typedef traits traits_type;
    typedef basic_ostream&lt;charT, traits&gt; ostream_type;
    typedef output_iterator_tag iterator_category;
    typedef void value_type;
    typedef void difference_type;
    typedef void pointer;
    typedef void reference;

    ostream_joiner(ostream_type&amp; s, const DelimT&amp; delimiter);
    ostream_joiner(ostream_type&amp; s, DelimT&amp;&amp; delimiter);
    template&lt;typename T&gt;
    ostream_joiner&amp; operator=(const T&amp; value);
    ostream_joiner&amp; operator*();
    ostream_joiner&amp; operator++();
    ostream_joiner&amp; operator++(int);
  private:
    ostream_type* out_stream; <i>// exposition only</i>
    DelimT delim;             <i>// exposition only</i>
    bool first_element;       <i>// exposition only</i>
  };
} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>

    <cxx-section id="iterator.ostream.joiner.cons">
    

    <section>
      <header><span class="section-number">6.2.1</span> <h1 data-bookmark-label="6.2.1 ostream_joiner constructor"><code>ostream_joiner</code> constructor</h1> <span style="float:right"><a href="#iterator.ostream.joiner.cons">[iterator.ostream.joiner.cons]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.cons.1">
    
    <pre><code><cxx-signature>ostream_joiner(ostream_type&amp; s, const DelimT&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="iterator.ostream.joiner.cons.2">
    
    <dt>Effects:</dt><dd>
          Initializes <code>out_stream</code> with <code>std::addressof(s)</code>,
          <code>delim</code> with <code>delimiter</code>,
          and <code>first_element</code> with <code>true</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="iterator.ostream.joiner.cons.3">
    
    <pre><code><cxx-signature>ostream_joiner(ostream_type&amp; s, DelimT&amp;&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="4" id="iterator.ostream.joiner.cons.4">
    
    <dt>Effects:</dt><dd>
          Initializes <code>out_stream</code> with <code>std::addressof(s)</code>,
          <code>delim</code> with <code>move(delimiter)</code>,
          and <code>first_element</code> with <code>true</code>.
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="iterator.ostream.joiner.ops">
    

    <section>
      <header><span class="section-number">6.2.2</span> <h1 data-bookmark-label="6.2.2 ostream_joiner operations"><code>ostream_joiner</code> operations</h1> <span style="float:right"><a href="#iterator.ostream.joiner.ops">[iterator.ostream.joiner.ops]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.ops.1">
    
    <pre><code><cxx-signature>template&lt;typename T&gt;
ostream_joiner&lt;DelimT, charT, traits&gt;&amp; operator=(const T&amp; value);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-effects para_num="2" id="iterator.ostream.joiner.ops.2">
    
    <dt>Effects:</dt><dd>
          <pre style="clear:left"><code>if (!first_element)
  *out_stream &lt;&lt; delim;
first_element = false;
*out_stream &lt;&lt; value;
return *this;</code></pre>
        </dd>
  </cxx-effects>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="3" id="iterator.ostream.joiner.ops.3">
    
    <pre><code><cxx-signature>ostream_joiner&lt;DelimT, charT, traits&gt;&amp; operator*();</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="4" id="iterator.ostream.joiner.ops.4">
    
    <dt>Returns:</dt><dd><code>*this</code></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>

      <cxx-function para_num="5" id="iterator.ostream.joiner.ops.5">
    
    <pre><code><cxx-signature>ostream_joiner&lt;DelimT, charT, traits&gt;&amp; operator++();</cxx-signature><cxx-signature>ostream_joiner&lt;DelimT, charT, traits&gt;&amp; operator++(int);</cxx-signature></code></pre>

    <dl>
      
        
        

        <cxx-returns para_num="6" id="iterator.ostream.joiner.ops.6">
    
    <dt>Returns:</dt><dd><code>*this</code></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="iterator.ostream.joiner.creation">
    

    <section>
      <header><span class="section-number">6.2.3</span> <h1 data-bookmark-label="6.2.3 ostream_joiner creation function"><code>ostream_joiner</code> creation function</h1> <span style="float:right"><a href="#iterator.ostream.joiner.creation">[iterator.ostream.joiner.creation]</a></span></header>
      
      

      <cxx-function para_num="1" id="iterator.ostream.joiner.creation.1">
    
    <pre><code><cxx-signature>template &lt;class charT, class traits, class DelimT&gt;
ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;
make_ostream_joiner(basic_ostream&lt;charT, traits&gt;&amp; os, DelimT&amp;&amp; delimiter);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-returns para_num="2" id="iterator.ostream.joiner.creation.2">
    
    <dt>Returns:</dt><dd><code>ostream_joiner&lt;decay_t&lt;DelimT&gt;, charT, traits&gt;(os, forward&lt;DelimT&gt;(delimiter));</code></dd>
  </cxx-returns>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="numeric">
    

    <section>
      <header><span class="section-number">7</span> <h1 data-bookmark-label="7 Numerics library">Numerics library</h1> <span style="float:right"><a href="#numeric">[numeric]</a></span></header>
      
  

  <cxx-section id="numeric.ops">
    

    <section>
      <header><span class="section-number">7.1</span> <h1 data-bookmark-label="7.1 Generalized numeric operations">Generalized numeric operations</h1> <span style="float:right"><a href="#numeric.ops">[numeric.ops]</a></span></header>
      
    

    <cxx-section id="numeric.ops.overview">
    

    <section>
      <header><span class="section-number">7.1.1</span> <h1 data-bookmark-label="7.1.1 Header <experimental/numeric> synopsis">Header &lt;experimental/numeric&gt; synopsis</h1> <span style="float:right"><a href="#numeric.ops.overview">[numeric.ops.overview]</a></span></header>
      
      

<pre><code>#include &lt;numeric&gt;

namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  <cxx-ref insynopsis="" to="numeric.ops.gcd">// <i><a title="numeric.ops.gcd" href="#numeric.ops.gcd">7.1.2</a>, Greatest common divisor</i></cxx-ref>
  template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M,N&gt; gcd(M m, N n);

  <cxx-ref insynopsis="" to="numeric.ops.lcm">// <i><a title="numeric.ops.lcm" href="#numeric.ops.lcm">7.1.3</a>, Least common multiple</i></cxx-ref>
  template&lt;class M, class N&gt;
  constexpr common_type_t&lt;M,N&gt; lcm(M m, N n);

} // inline namespace fundamentals_v2
} // namespace experimental
} // namespace std</code></pre>
    
    </section>
  </cxx-section>

    <cxx-section id="numeric.ops.gcd">
    

    <section>
      <header><span class="section-number">7.1.2</span> <h1 data-bookmark-label="7.1.2 Greatest common divisor">Greatest common divisor</h1> <span style="float:right"><a href="#numeric.ops.gcd">[numeric.ops.gcd]</a></span></header>
      
      

      <cxx-function para_num="1" id="numeric.ops.gcd.1">
    
    <pre><code><cxx-signature>template&lt;class M, class N&gt;
constexpr common_type_t&lt;M,N&gt; gcd(M m, N n);</cxx-signature></code></pre>

    <dl>
      
        

        <cxx-requires para_num="2" id="numeric.ops.gcd.2">
    
    <dt>Requires:</dt><dd>
          <code>|m|</code> shall be representable as a value of type <code>M</code> and
          <code>|n|</code> shall be representable as a value of type <code>N</code>.
          <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    These requirements ensure, for example, that <code>gcd(m, m) = |m|</code> is representable as a value of type <code>M</code>.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
        </dd>
  </cxx-requires>
        <cxx-remarks para_num="3" id="numeric.ops.gcd.3">
    
    <dt>Remarks:</dt><dd>If either <code>M</code> or <code>N</code> is not an integer type, the program is ill-formed.</dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="numeric.ops.gcd.4">
    
    <dt>Returns:</dt><dd>
          zero when <code>m</code> and <code>n</code> are both zero.
          Otherwise, returns the greatest common divisor of <code>|m|</code> and <code>|n|</code>.</dd>
  </cxx-returns>
        <cxx-throws para_num="5" id="numeric.ops.gcd.5">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>

    <cxx-section id="numeric.ops.lcm">
    

    <section>
      <header><span class="section-number">7.1.3</span> <h1 data-bookmark-label="7.1.3 Least common multiple">Least common multiple</h1> <span style="float:right"><a href="#numeric.ops.lcm">[numeric.ops.lcm]</a></span></header>
      
      
      <cxx-function para_num="1" id="numeric.ops.lcm.1">
    
    <pre><code><cxx-signature>template&lt;class M, class N&gt;
constexpr common_type_t&lt;M,N&gt; lcm(M m, N n);</cxx-signature></code></pre>

    <dl>
      
        
        <cxx-requires para_num="2" id="numeric.ops.lcm.2">
    
    <dt>Requires:</dt><dd>
          <code>|m|</code> shall be representable as a value of type <code>M</code> and
          <code>|n|</code> shall be representable as a value of type <code>N</code>.
          The least common multiple of <code>|m|</code> and <code>|n|</code>
          shall be representable as a value of type <code>common_type_t&lt;M,N&gt;</code>.
        </dd>
  </cxx-requires>
        <cxx-remarks para_num="3" id="numeric.ops.lcm.3">
    
    <dt>Remarks:</dt><dd>If either <code>M</code> or <code>N</code> is not an integer type, the program is ill-formed.</dd>
  </cxx-remarks>
        <cxx-returns para_num="4" id="numeric.ops.lcm.4">
    
    <dt>Returns:</dt><dd>
          zero when either <code>m</code> or <code>n</code> is zero.
          Otherwise, returns the least common multiple of <code>|m|</code> and <code>|n|</code>.
        </dd>
  </cxx-returns>
        <cxx-throws para_num="5" id="numeric.ops.lcm.5">
    
    <dt>Throws:</dt><dd>Nothing.</dd>
  </cxx-throws>
      
    </dl>
  </cxx-function>
    
    </section>
  </cxx-section>
  
    </section>
  </cxx-section>

    </section>
  </cxx-clause>

<cxx-clause id="reflection">
    

    <section>
      <header><span class="section-number">8</span> <h1 data-bookmark-label="8 Reflection library">Reflection library</h1> <span style="float:right"><a href="#reflection">[reflection]</a></span></header>
      
  

  <cxx-section id="reflection.src_loc">
    

    <section>
      <header><span class="section-number">8.1</span> <h1 data-bookmark-label="8.1 Class source_location">Class source_location</h1> <span style="float:right"><a href="#reflection.src_loc">[reflection.src_loc]</a></span></header>
      
    

    <cxx-section id="reflection.src_loc.intro">
    

    <section>
      <header><span class="section-number">8.1.1</span> <h1 data-bookmark-label="8.1.1 Header <experimental/source_location> synopsis">Header <code>&lt;experimental/source_location&gt;</code> synopsis</h1> <span style="float:right"><a href="#reflection.src_loc.intro">[reflection.src_loc.intro]</a></span></header>
      
    

<pre><code>namespace std {
namespace experimental {
inline namespace fundamentals_v2 {

  struct source_location {
    constexpr source_location() noexcept;

    constexpr uint_least32_t line() const noexcept;
    constexpr uint_least32_t column() const noexcept;
    constexpr const char* file_name() const noexcept;
    constexpr const char* function_name() const noexcept;

    static constexpr source_location current() noexcept;
  };

} // namespace fundamentals_v1
} // namespace experimental
} // namespace std</code></pre>

    <p para_num="1" id="reflection.src_loc.intro.1">
      <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    The intent of <code>source_location</code> is to have a small size and efficient copying.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
    </p>

    <cxx-function para_num="2" id="reflection.src_loc.intro.2">
    
    <pre><code><cxx-signature>constexpr source_location() noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-effects para_num="3" id="reflection.src_loc.intro.3">
    
    <dt>Effects:</dt><dd>Constructs an object of class <code>source_location</code>.</dd>
  </cxx-effects>
      <cxx-remarks para_num="4" id="reflection.src_loc.intro.4">
    
    <dt>Remarks:</dt><dd>The values are implementation-defined.</dd>
  </cxx-remarks>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="5" id="reflection.src_loc.intro.5">
    
    <pre><code><cxx-signature>constexpr uint_least32_t line() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="6" id="reflection.src_loc.intro.6">
    
    <dt>Returns:</dt><dd>The presumed line number (<cxx-ref in="cxx" to="cpp.predefined">C++14 <span title="cpp.predefined">§16.8</span></cxx-ref>) represented by this object.</dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="7" id="reflection.src_loc.intro.7">
    
    <pre><code><cxx-signature>constexpr uint_least32_t column() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="8" id="reflection.src_loc.intro.8">
    
    <dt>Returns:</dt><dd>
        An implementation-defined value representing
        some offset from the start of the line represented by this object.
      </dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="9" id="reflection.src_loc.intro.9">
    
    <pre><code><cxx-signature>constexpr const char* file_name() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="10" id="reflection.src_loc.intro.10">
    
    <dt>Returns:</dt><dd>
        The presumed name of the current source file (<cxx-ref in="cxx" to="cpp.predefined">C++14 <span title="cpp.predefined">§16.8</span></cxx-ref>)
        represented by this object as an NTBS.
      </dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="11" id="reflection.src_loc.intro.11">
    
    <pre><code><cxx-signature>constexpr const char* function_name() const noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="12" id="reflection.src_loc.intro.12">
    
    <dt>Returns:</dt><dd>
        If this object represents a position in the body of a function,
        returns an implementation-defined NTBS that should correspond to the function name.
        Otherwise, returns an empty string.
      </dd>
  </cxx-returns>
    
    </dl>
  </cxx-function>

    <cxx-function para_num="13" id="reflection.src_loc.intro.13">
    
    <pre><code><cxx-signature>static constexpr source_location current() noexcept;</cxx-signature></code></pre>

    <dl>
      
      

      <cxx-returns para_num="14" id="reflection.src_loc.intro.14">
    
    <dt>Returns:</dt><dd>
        When invoked by a function call (<cxx-ref in="cxx" to="expr.call">C++14 <span title="expr.call">§5.2.2</span></cxx-ref>)
        whose <cxx-grammarterm><i>postfix-expression</i></cxx-grammarterm> is
        a (possibly parenthesized) <cxx-grammarterm><i>id-expression</i></cxx-grammarterm> naming <code>current</code>,
        returns a <code>source_location</code> with an implementation-defined value.
        The value should be affected by <code>#line</code>
        (<cxx-ref in="cxx" to="cpp.line">C++14 <span title="cpp.line">§16.4</span></cxx-ref>) in the same manner as for <code>__LINE__</code> and <code>__FILE__</code>.
        If invoked in some other way, the value returned is unspecified.
      </dd>
  </cxx-returns>
      <cxx-remarks para_num="15" id="reflection.src_loc.intro.15">
    
    <dt>Remarks:</dt><dd>
        When a <cxx-grammarterm><i>brace-or-equal-initializer</i></cxx-grammarterm> is used to initialize a non-static data member,
        any calls to <code>current</code> should correspond to the location of
        the constructor or aggregate initialization that initializes the member.
      </dd>
  </cxx-remarks>
      <p para_num="16" id="reflection.src_loc.intro.16">
        <cxx-note><span class="nowrap">[ <em>Note:</em></span>
    When used as a default argument (<cxx-ref in="cxx" to="dcl.fct.default">C++14 <span title="dcl.fct.default">§8.3.6</span></cxx-ref>),
          the value of the <code>source_location</code> will be the location of the call to <code>current</code> at the call site.
    <span class="nowrap">— <em>end note</em> ]</span>
  </cxx-note>
      </p>
      <cxx-example>
    
    <span class="nowrap">[ <em>Example:</em></span>
    
        <pre><code>struct s {
  source_location member = source_location::current();
  int other_member;
  s(source_location loc = source_location::current())
    : member(loc) // <i>values of</i> member <i>will be from call-site</i>
  {}
  s(int blather) : // <i>values of</i> member <i>should be hereabouts</i>
    other_member(blather) {}
  s(double) // <i>values of</i> member <i>should be hereabouts</i>
  {}
};

void f(source_location a = source_location::current()) {
  source_location b = source_location::current(); // <i>values in</i> b <i>represent this line</i>
}

void g() {
  f(); // f<i>’s first argument corresponds to this line of code</i>

  source_location c = source_location::current();
  f(c); // f<i>’s first argument gets the same values as </i>c<i>, above</i>
}</code></pre>
      
    <span class="nowrap">— <em>end example</em> ]</span>
  </cxx-example>
    
    </dl>
  </cxx-function>
  
    </section>
  </cxx-section>

    </section>
  </cxx-section>
    </section>
  </cxx-clause>





</body></html>